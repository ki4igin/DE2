--------------------------------------------------------------------------------
--
-- Design unit generated by Aldec IP Core Generator, version 11.1.
-- Copyright (c) 1997 - 2019 by Aldec, Inc. All rights reserved.
--
--------------------------------------------------------------------------------
--
-- Created on Monday 2020-12-14, 12:00:44
--
--------------------------------------------------------------------------------
-- Details:
--		Type: Serial Distributed Arithmetic FIR filter
--		Data input DATA width: 16
--		Data output OUT_READY width: 16
--		Coefficient width: 16
--		Taps number: 21
--		Filter is non-symmetric
--------------------------------------------------------------------------------

--{{ Section below this comment is automatically maintained
--   and may be overwritten
--{entity {sdafir} architecture {sdafir_arch}}

library IEEE;
use IEEE.std_logic_1164.all;
entity sdafir is
	port(
		DATA : in std_logic_vector(15 downto 0);
		RSLT : out std_logic_vector(15 downto 0);
		CLK : in std_logic;
		RESET : in std_logic;
		NEW_READY : out std_logic;
		OUT_READY : out std_logic
	);
end entity;

--}} End of automatically maintained section

library IEEE;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
-- synopsys translate_off
library UNISIM;
use UNISIM.VCOMPONENTS.all;
-- synopsys translate_on

architecture sdafir_arch of sdafir is

component RAM16X1S
	port(
		D : in std_logic;
		A3 : in  std_logic;
		A2 : in  std_logic;
		A1 : in  std_logic;
		A0 : in  std_logic;
		WE : in  std_logic;
		WCLK : in  std_logic;
		O : out std_logic);
end component;

type ROM4 is array(0 to 15) of std_logic_vector(17 downto 0);
constant MEM4 : ROM4 := ("000000000000000000","001001111110110011","001110010111001001","011000010101111101","001001111110110011","010011111101100111","011000010101111101","100010010100110001","000001100000101000","001011011111011100","001111110111110001","011001110110100101","001011011111011100","010101011110010000","011001110110100101","100011110101011001");
type ROM3 is array(0 to 15) of std_logic_vector(15 downto 0);
constant MEM3 : ROM3 := ("0000000000000000","0001010000101001","1110100011110101","1111110100011110","1101000010111011","1110010011100100","1011100110101111","1100110111011000","0001100000101000","0010110001010001","0000000100011100","0001010101000101","1110100011100011","1111110100001100","1101000111010111","1110011000000000");
type ROM5 is array(0 to 15) of std_logic_vector(15 downto 0);
constant MEM5 : ROM5 := ("0000000000000000","1101000010111011","1110100011110101","1011100110101111","0001010000101001","1110010011100100","1111110100011110","1100110111011000","0001001001000110","1110001100000001","1111101100111011","1100101111110101","0010011001101111","1111011100101010","0000111101100011","1110000000011110");
type ROM2 is array(0 to 15) of std_logic_vector(13 downto 0);
constant MEM2 : ROM2 := ("00000000000000","00000101010100","11000010000111","11000111011100","11011010111101","11100000010010","10011101000011","10100010011000","01001001000110","01001110011011","00001011001100","00010000100001","00100100000010","00101001010111","11100110001010","11101011011110");
type ROM6 is array(0 to 15) of std_logic_vector(13 downto 0);
constant MEM6 : ROM6 := ("00000000000000","11011010111101","11000010000111","10011101000011","00000101010100","11100000010010","11000111011100","10100010011000","01001111100101","00101010100010","00010001101100","11101100101001","01010100111010","00101111110111","00010111000001","11110001111110");
type ROM1 is array(0 to 1) of std_logic_vector(12 downto 0);
constant MEM1 : ROM1 := ("0000000000000","0100111110010");
signal SIG1 :  std_logic_vector(20 downto 0);
signal WE : std_logic;
signal L2 : std_logic_vector(3 downto 0);
signal reg	: std_logic_vector(15 downto 0);
signal INADD : std_logic_vector(20 downto 0);
signal OUT_SM : std_logic_vector(21 downto 0);
signal OUT_4 : std_logic_vector(17 downto 0);
signal OUT_3 : std_logic_vector(15 downto 0);
signal OUT_5 : std_logic_vector(15 downto 0);
signal OUT_2 : std_logic_vector(13 downto 0);
signal OUT_6 : std_logic_vector(13 downto 0);
signal OUT_1 : std_logic_vector(12 downto 0);
signal ADD1 : std_logic_vector(18 downto 0);
signal ADD2 : std_logic_vector(14 downto 0);
signal ADD3 : std_logic_vector(16 downto 0);
signal ADD4 : std_logic_vector(16 downto 0);
signal ADD5 : std_logic_vector(19 downto 0);
signal ADD6 : std_logic_vector(17 downto 0);

begin

	WE <= '1';

	L1 : for i in 1 to 20 generate
		RM : RAM16X1S port map(D => SIG1(i-1), A3 => L2(3), A2 => L2(2), A1 => L2(1), A0 => L2(0), WE => WE, WCLK => CLK, O => SIG1(i));
	end generate;

	process(CLK, RESET)
	variable n_r,o_r : std_logic;
	begin
		if RESET = '1' then
			n_r := '1';
			o_r := '0';
			NEW_READY <= '1';
			OUT_READY <= '0';
			RSLT <= (others=>'0');
			L2 <= "1111";
			reg<=(others=>'0');
			SIG1(0) <= '0';
			OUT_SM <= (others=>'0');
			INADD <= (others=>'0');
			OUT_1 <= (others=>'0');
			OUT_2 <= (others=>'0');
			ADD1 <= (others=>'0');
			ADD2 <= (others=>'0');
			OUT_3 <= (others=>'0');
			OUT_4 <= (others=>'0');
			ADD3 <= (others=>'0');
			ADD4 <= (others=>'0');
			ADD5 <= (others=>'0');
			ADD6 <= (others=>'0');
			OUT_5 <= (others=>'0');
			OUT_6 <= (others=>'0');
		elsif rising_edge(CLK) then
			case L2 is
				when "1111" =>
					L2<="0000"; 
					n_r := '1';
					reg<=DATA;
				when others =>
					L2<=L2+'1';
					n_r := '0';
			end case;

			case L2 is
				when "0100" =>
					OUT_SM <= SXT(OUT_SM(OUT_SM'left downto 1),OUT_SM'left+1) - SXT(INADD,OUT_SM'left+1);
					o_r:='0';
				when "0101" =>
					OUT_SM <= SXT(INADD,OUT_SM'left+1);
					RSLT <= OUT_SM(OUT_SM'left downto OUT_SM'left-15);
					o_r:='1';
				when others =>
					OUT_SM <= SXT(INADD,OUT_SM'left+1) + SXT(OUT_SM(OUT_SM'left downto 1),OUT_SM'left+1);
					o_r:='0';
			end case;

			SIG1(0)<= reg(CONV_INTEGER(L2));
			OUT_1 <= MEM1(CONV_INTEGER(SIG1(0 downto 0)));
			OUT_2 <= MEM2(CONV_INTEGER(SIG1(4 downto 1)));
			OUT_3 <= MEM3(CONV_INTEGER(SIG1(8 downto 5)));
			OUT_4 <= MEM4(CONV_INTEGER(SIG1(12 downto 9)));
			OUT_5 <= MEM5(CONV_INTEGER(SIG1(16 downto 13)));
			OUT_6 <= MEM6(CONV_INTEGER(SIG1(20 downto 17)));
			ADD1 <= SXT(OUT_4,ADD1'LEFT+1);
			ADD2 <= SXT(OUT_2,ADD2'LEFT+1) + SXT(OUT_6,ADD2'LEFT+1);
			ADD3 <= SXT(OUT_3,ADD3'LEFT+1);
			ADD4 <= SXT(OUT_5,ADD4'LEFT+1) + SXT(OUT_1,ADD4'LEFT+1);
			ADD5 <= SXT(ADD1,ADD5'LEFT+1) + SXT(ADD2,ADD5'LEFT+1);
			ADD6 <= SXT(ADD3,ADD6'LEFT+1) + SXT(ADD4,ADD6'LEFT+1);
			INADD <= SXT(ADD5,INADD'LEFT+1) + SXT(ADD6,INADD'LEFT+1);
			NEW_READY <= n_r;
			OUT_READY <= o_r;
		end if;
	end process;

end architecture;
