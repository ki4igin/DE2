
led_blink.elf:     file format elf32-littlenios2
led_blink.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00080168

Program Header:
    LOAD off    0x00001020 vaddr 0x00080020 paddr 0x00080020 align 2**12
         filesz 0x00003464 memsz 0x00003580 flags rwx
    LOAD off    0x00005000 vaddr 0x00100000 paddr 0x00100000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00100000  00100000  00005000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000148  00080020  00080020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001ef8  00080168  00080168  00001168  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000040  00082060  00082060  00003060  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000013e4  000820a0  000820a0  000030a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000011c  00083484  00083484  00004484  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  00005000  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000004d0  00000000  00000000  00005028  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000915  00000000  00000000  000054f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00007e83  00000000  00000000  00005e0d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002847  00000000  00000000  0000dc90  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00005fdb  00000000  00000000  000104d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000810  00000000  00000000  000164b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000017d3  00000000  00000000  00016cc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00001da3  00000000  00000000  00018497  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  0001a23c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000001a8  00000000  00000000  0001a250  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0001bdba  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  0001bdbd  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0001bdc0  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0001bdc1  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0001bdc2  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  0001bdc6  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  0001bdca  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  0001bdce  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000009  00000000  00000000  0001bdd7  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000009  00000000  00000000  0001bde0  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 00000004  00000000  00000000  0001bde9  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000015  00000000  00000000  0001bded  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     00033615  00000000  00000000  0001be02  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00100000 l    d  .entry	00000000 .entry
00080020 l    d  .exceptions	00000000 .exceptions
00080168 l    d  .text	00000000 .text
00082060 l    d  .rodata	00000000 .rodata
000820a0 l    d  .rwdata	00000000 .rwdata
00083484 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
0008019c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 led_blink.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
000820a0 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00082180 l     O .rwdata	000000c8 epcs
00082248 l     O .rwdata	00001060 jtag_uart
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00080c2c l     F .text	00000054 altera_avalon_jtag_uart_timeout
00080d00 l     F .text	00000134 altera_avalon_jtag_uart_irq
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 epcs_commands.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev.c
000816e8 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
000818e4 l     F .text	00000078 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 lib2-mul.c
000805dc g     F .text	00000038 alt_epcs_flash_get_info
00080418 g     F .text	00000044 alt_main
00080220 g     F .text	00000090 _puts_r
000834a0 g     O .bss	00000100 alt_irq
00000000  w      *UND*	00000000 __errno
00081354 g     F .text	000000cc epcs_sector_erase
00100000 g     F .entry	00000000 __reset
00083484 g     O .bss	00000004 errno
0008348c g     O .bss	00000004 alt_argv
0008b450 g       *ABS*	00000000 _gp
000832d0 g     O .rwdata	00000180 alt_fd_list
000815fc g     F .text	00000058 epcs_write_status_register
00081df4 g     F .text	00000070 alt_find_dev
00081ffc g     F .text	0000002c memcpy
0008195c g     F .text	00000098 alt_io_redirect
000802b0 g     F .text	00000014 puts
00080684 g     F .text	000000d8 alt_epcs_flash_write_block
00080ea8 g     F .text	00000168 altera_avalon_jtag_uart_read
00083468 g     O .rwdata	00000004 alt_max_fd
00080b04 g     F .text	00000058 alt_epcs_flash_erase_block
00083454 g     O .rwdata	00000004 _global_impure_ptr
00081278 g     F .text	0000004c epcs_exit_4_bytes_mode
000835a0 g       *ABS*	00000000 __bss_end
0008187c g     F .text	00000068 alt_iic_isr_register
00081c14 g     F .text	000000ac alt_tick
000817c4 g     F .text	00000018 alt_ic_irq_enabled
00081be0 g     F .text	00000034 alt_alarm_stop
00083494 g     O .bss	00000004 alt_irq_active
000800ec g     F .exceptions	0000007c alt_irq_handler
000832a8 g     O .rwdata	00000028 alt_dev_null
00083460 g     O .rwdata	00000008 alt_dev_list
0008045c g     F .text	00000110 write
000811ec g     F .text	00000054 epcs_read_electronic_signature
000835a0 g       *ABS*	00000000 end
00080c80 g     F .text	00000080 altera_avalon_jtag_uart_init
00100000 g       *ABS*	00000000 __alt_stack_pointer
00081010 g     F .text	0000017c altera_avalon_jtag_uart_write
00080168 g     F .text	00000038 _start
00083498 g     O .bss	00000004 _alt_tick_rate
00081cc8 g     F .text	0000012c alt_avalon_spi_command
0008349c g     O .bss	00000004 _alt_nticks
0008056c g     F .text	00000050 alt_sys_init
00080bf4 g     F .text	00000038 altera_avalon_jtag_uart_close
00082028 g     F .text	00000038 __mulsi3
00081310 g     F .text	00000044 epcs_read_status_register
00080bcc g     F .text	00000028 altera_avalon_jtag_uart_read_fd
00081f20 g     F .text	000000a0 alt_get_fd
0008118c g     F .text	00000060 epcs_read_device_id
00081fc0 g     F .text	0000003c memcmp
00080b7c g     F .text	00000028 altera_avalon_jtag_uart_close_fd
000835a0 g       *ABS*	00000000 __alt_stack_base
00080b5c g     F .text	00000020 altera_avalon_jtag_uart_ioctl_fd
00081e64 g     F .text	000000bc alt_find_file
000816f0 g     F .text	00000070 alt_dev_llist_insert
00083470 g     O .rwdata	00000008 alt_flash_dev_list
000802e4 g     F .text	000000bc __sfvwrite_small_dev
00083484 g       *ABS*	00000000 __bss_start
000801a0 g     F .text	00000080 main
00083490 g     O .bss	00000004 alt_envp
00080ba4 g     F .text	00000028 altera_avalon_jtag_uart_write_fd
0008346c g     O .rwdata	00000004 alt_errno
00080000 g       *ABS*	00000000 __alt_mem_sram_ext
0008075c g     F .text	000001c8 alt_epcs_flash_write
000805bc g     F .text	00000020 alt_irq_init
00081b78 g     F .text	00000068 alt_release_fd
000803a0 g     F .text	00000078 _write_r
00083450 g     O .rwdata	00000004 _impure_ptr
00083488 g     O .bss	00000004 alt_argc
00080020 g       .exceptions	00000000 alt_irq_entry
00083458 g     O .rwdata	00000008 alt_fs_list
00081524 g     F .text	000000d8 epcs_read_buffer
00080924 g     F .text	000001e0 alt_epcs_flash_init
0008185c g     F .text	00000020 alt_ic_isr_register
00083484 g       *ABS*	00000000 _edata
000835a0 g       *ABS*	00000000 _end
00081784 g     F .text	00000040 alt_flash_open_dev
00080e34 g     F .text	00000074 altera_avalon_jtag_uart_ioctl
0008181c g     F .text	00000040 alt_ic_irq_disable
000812c4 g     F .text	0000004c epcs_enter_4_bytes_mode
00081cc0 g     F .text	00000008 altera_nios2_qsys_irq_init
00100000 g       .entry	00000000 exit
00081760 g     F .text	00000024 alt_flash_close_dev
00100000 g       *ABS*	00000000 __alt_data_end
00080020 g     F .exceptions	00000000 alt_exception
00100000 g       .entry	00000000 _exit
00081654 g     F .text	00000094 alt_alarm_start
000802c4 g     F .text	00000020 strlen
00081240 g     F .text	00000038 epcs_write_enable
000819f4 g     F .text	00000184 open
00083478 g     O .rwdata	00000004 alt_priority_mask
000817dc g     F .text	00000040 alt_ic_irq_enable
00100000 g       *ABS*	00000000 __alt_mem_epcs
00080614 g     F .text	00000070 alt_epcs_flash_read
0008347c g     O .rwdata	00000008 alt_alarm_list
00081420 g     F .text	00000104 epcs_write_buffer



Disassembly of section .exceptions:

00080020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
   80020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
   80024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
   80028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   8002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   80030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   80034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   80038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   8003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   80040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
   80044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
   80048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   8004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   80050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   80054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   80058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   8005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   80060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   80064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   80068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   8006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   80070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   80074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   80078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   8007c:	10000326 	beq	r2,zero,8008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   80080:	20000226 	beq	r4,zero,8008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   80084:	00800ec0 	call	800ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   80088:	00000306 	br	80098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
   8008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
   80090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
   80094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   80098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   8009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   800a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   800a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   800a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   800ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   800b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   800b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   800b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   800bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   800c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
   800c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   800c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   800cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   800d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   800d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   800d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   800dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   800e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
   800e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   800e8:	ef80083a 	eret

000800ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   800ec:	defffe04 	addi	sp,sp,-8
   800f0:	dfc00115 	stw	ra,4(sp)
   800f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   800f8:	000d313a 	rdctl	r6,ipending
   800fc:	04000234 	movhi	r16,8
   80100:	840d2804 	addi	r16,r16,13472
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   80104:	3080004c 	andi	r2,r6,1
   80108:	1005003a 	cmpeq	r2,r2,zero
   8010c:	10000a1e 	bne	r2,zero,80138 <alt_irq_handler+0x4c>
   80110:	0009883a 	mov	r4,zero
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   80114:	200490fa 	slli	r2,r4,3
   80118:	1405883a 	add	r2,r2,r16
   8011c:	10c00017 	ldw	r3,0(r2)
   80120:	11000117 	ldw	r4,4(r2)
   80124:	183ee83a 	callr	r3
   80128:	0005313a 	rdctl	r2,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
   8012c:	10000a26 	beq	r2,zero,80158 <alt_irq_handler+0x6c>
   80130:	100d883a 	mov	r6,r2
   80134:	003ff306 	br	80104 <alt_irq_handler+0x18>
   80138:	00c00044 	movi	r3,1
   8013c:	0009883a 	mov	r4,zero
   80140:	180b883a 	mov	r5,r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
   80144:	18c7883a 	add	r3,r3,r3
      i++;
   80148:	2149883a 	add	r4,r4,r5
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   8014c:	30c4703a 	and	r2,r6,r3
   80150:	103ff01e 	bne	r2,zero,80114 <alt_irq_handler+0x28>
   80154:	003ffb06 	br	80144 <alt_irq_handler+0x58>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
   80158:	dfc00117 	ldw	ra,4(sp)
   8015c:	dc000017 	ldw	r16,0(sp)
   80160:	dec00204 	addi	sp,sp,8
   80164:	f800283a 	ret

Disassembly of section .text:

00080168 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   80168:	06c00434 	movhi	sp,16
    ori sp, sp, %lo(__alt_stack_pointer)
   8016c:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
   80170:	06800234 	movhi	gp,8
    ori gp, gp, %lo(_gp)
   80174:	d6ad1414 	ori	gp,gp,46160
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   80178:	00800234 	movhi	r2,8
    ori r2, r2, %lo(__bss_start)
   8017c:	108d2114 	ori	r2,r2,13444

    movhi r3, %hi(__bss_end)
   80180:	00c00234 	movhi	r3,8
    ori r3, r3, %lo(__bss_end)
   80184:	18cd6814 	ori	r3,r3,13728

    beq r2, r3, 1f
   80188:	10c00326 	beq	r2,r3,80198 <_start+0x30>

0:
    stw zero, (r2)
   8018c:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   80190:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   80194:	10fffd36 	bltu	r2,r3,8018c <_start+0x24>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   80198:	00804180 	call	80418 <alt_main>

0008019c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   8019c:	003fff06 	br	8019c <alt_after_alt_main>

000801a0 <main>:
#include <stdio.h>
#include "altera_avalon_pio_regs.h"
#include "system.h"

int main()
{
   801a0:	defffc04 	addi	sp,sp,-16
   801a4:	dfc00315 	stw	ra,12(sp)
   801a8:	df000215 	stw	fp,8(sp)
   801ac:	df000204 	addi	fp,sp,8
    printf("Hello from Nios II!\n");
   801b0:	01000234 	movhi	r4,8
   801b4:	21081804 	addi	r4,r4,8288
   801b8:	00802b00 	call	802b0 <puts>

    while (1)
    {
        int leds = 0x1;
   801bc:	00800044 	movi	r2,1
   801c0:	e0bfff15 	stw	r2,-4(fp)
        int i = 0;
   801c4:	e03ffe15 	stw	zero,-8(fp)
        while (1)
        {
            IOWR_ALTERA_AVALON_PIO_DATA(PIO_LEDG_BASE, leds);
   801c8:	00c00434 	movhi	r3,16
   801cc:	18c60004 	addi	r3,r3,6144
   801d0:	e0bfff17 	ldw	r2,-4(fp)
   801d4:	18800035 	stwio	r2,0(r3)
            for (i = 0; i < (ALT_CPU_CPU_FREQ / 500); i++)
   801d8:	e03ffe15 	stw	zero,-8(fp)
   801dc:	00000306 	br	801ec <main+0x4c>
   801e0:	e0bffe17 	ldw	r2,-8(fp)
   801e4:	10800044 	addi	r2,r2,1
   801e8:	e0bffe15 	stw	r2,-8(fp)
   801ec:	e0fffe17 	ldw	r3,-8(fp)
   801f0:	008000b4 	movhi	r2,2
   801f4:	10a1a7c4 	addi	r2,r2,-31073
   801f8:	10fff92e 	bgeu	r2,r3,801e0 <main+0x40>
                ; // Delay
            // Johnson code counter on leds
            leds = ((leds << 1) & 0xFE) | (!(leds >> 7) & 0x1);
   801fc:	e0bfff17 	ldw	r2,-4(fp)
   80200:	1085883a 	add	r2,r2,r2
   80204:	10c03f8c 	andi	r3,r2,254
   80208:	e0bfff17 	ldw	r2,-4(fp)
   8020c:	1005d1fa 	srai	r2,r2,7
   80210:	1005003a 	cmpeq	r2,r2,zero
   80214:	1884b03a 	or	r2,r3,r2
   80218:	e0bfff15 	stw	r2,-4(fp)
            //printf("%d ", leds);
        }
   8021c:	003fea06 	br	801c8 <main+0x28>

00080220 <_puts_r>:
   80220:	defffd04 	addi	sp,sp,-12
   80224:	dc000015 	stw	r16,0(sp)
   80228:	2021883a 	mov	r16,r4
   8022c:	2809883a 	mov	r4,r5
   80230:	dfc00215 	stw	ra,8(sp)
   80234:	dc400115 	stw	r17,4(sp)
   80238:	2823883a 	mov	r17,r5
   8023c:	00802c40 	call	802c4 <strlen>
   80240:	80c00217 	ldw	r3,8(r16)
   80244:	02000234 	movhi	r8,8
   80248:	4200b904 	addi	r8,r8,740
   8024c:	880d883a 	mov	r6,r17
   80250:	100f883a 	mov	r7,r2
   80254:	8009883a 	mov	r4,r16
   80258:	180b883a 	mov	r5,r3
   8025c:	1a000115 	stw	r8,4(r3)
   80260:	403ee83a 	callr	r8
   80264:	047fffc4 	movi	r17,-1
   80268:	8009883a 	mov	r4,r16
   8026c:	01800234 	movhi	r6,8
   80270:	31881d04 	addi	r6,r6,8308
   80274:	01c00044 	movi	r7,1
   80278:	1440071e 	bne	r2,r17,80298 <_puts_r+0x78>
   8027c:	00ffffc4 	movi	r3,-1
   80280:	1805883a 	mov	r2,r3
   80284:	dfc00217 	ldw	ra,8(sp)
   80288:	dc400117 	ldw	r17,4(sp)
   8028c:	dc000017 	ldw	r16,0(sp)
   80290:	dec00304 	addi	sp,sp,12
   80294:	f800283a 	ret
   80298:	81400217 	ldw	r5,8(r16)
   8029c:	28c00117 	ldw	r3,4(r5)
   802a0:	183ee83a 	callr	r3
   802a4:	0007883a 	mov	r3,zero
   802a8:	147ff51e 	bne	r2,r17,80280 <_puts_r+0x60>
   802ac:	003ff306 	br	8027c <_puts_r+0x5c>

000802b0 <puts>:
   802b0:	00800234 	movhi	r2,8
   802b4:	108d1404 	addi	r2,r2,13392
   802b8:	200b883a 	mov	r5,r4
   802bc:	11000017 	ldw	r4,0(r2)
   802c0:	00802201 	jmpi	80220 <_puts_r>

000802c4 <strlen>:
   802c4:	20800007 	ldb	r2,0(r4)
   802c8:	10000526 	beq	r2,zero,802e0 <strlen+0x1c>
   802cc:	2007883a 	mov	r3,r4
   802d0:	18c00044 	addi	r3,r3,1
   802d4:	18800007 	ldb	r2,0(r3)
   802d8:	103ffd1e 	bne	r2,zero,802d0 <strlen+0xc>
   802dc:	1905c83a 	sub	r2,r3,r4
   802e0:	f800283a 	ret

000802e4 <__sfvwrite_small_dev>:
   802e4:	2880000b 	ldhu	r2,0(r5)
   802e8:	defffa04 	addi	sp,sp,-24
   802ec:	dcc00315 	stw	r19,12(sp)
   802f0:	1080020c 	andi	r2,r2,8
   802f4:	dc800215 	stw	r18,8(sp)
   802f8:	dc400115 	stw	r17,4(sp)
   802fc:	dfc00515 	stw	ra,20(sp)
   80300:	dd000415 	stw	r20,16(sp)
   80304:	dc000015 	stw	r16,0(sp)
   80308:	2825883a 	mov	r18,r5
   8030c:	2027883a 	mov	r19,r4
   80310:	3023883a 	mov	r17,r6
   80314:	10002026 	beq	r2,zero,80398 <__sfvwrite_small_dev+0xb4>
   80318:	2940008f 	ldh	r5,2(r5)
   8031c:	28000f16 	blt	r5,zero,8035c <__sfvwrite_small_dev+0x78>
   80320:	01c01b0e 	bge	zero,r7,80390 <__sfvwrite_small_dev+0xac>
   80324:	3821883a 	mov	r16,r7
   80328:	05010004 	movi	r20,1024
   8032c:	00000206 	br	80338 <__sfvwrite_small_dev+0x54>
   80330:	0400170e 	bge	zero,r16,80390 <__sfvwrite_small_dev+0xac>
   80334:	9140008f 	ldh	r5,2(r18)
   80338:	880d883a 	mov	r6,r17
   8033c:	9809883a 	mov	r4,r19
   80340:	800f883a 	mov	r7,r16
   80344:	a400010e 	bge	r20,r16,8034c <__sfvwrite_small_dev+0x68>
   80348:	01c10004 	movi	r7,1024
   8034c:	00803a00 	call	803a0 <_write_r>
   80350:	88a3883a 	add	r17,r17,r2
   80354:	80a1c83a 	sub	r16,r16,r2
   80358:	00bff516 	blt	zero,r2,80330 <__sfvwrite_small_dev+0x4c>
   8035c:	9080000b 	ldhu	r2,0(r18)
   80360:	00ffffc4 	movi	r3,-1
   80364:	10801014 	ori	r2,r2,64
   80368:	9080000d 	sth	r2,0(r18)
   8036c:	1805883a 	mov	r2,r3
   80370:	dfc00517 	ldw	ra,20(sp)
   80374:	dd000417 	ldw	r20,16(sp)
   80378:	dcc00317 	ldw	r19,12(sp)
   8037c:	dc800217 	ldw	r18,8(sp)
   80380:	dc400117 	ldw	r17,4(sp)
   80384:	dc000017 	ldw	r16,0(sp)
   80388:	dec00604 	addi	sp,sp,24
   8038c:	f800283a 	ret
   80390:	0007883a 	mov	r3,zero
   80394:	003ff506 	br	8036c <__sfvwrite_small_dev+0x88>
   80398:	00ffffc4 	movi	r3,-1
   8039c:	003ff306 	br	8036c <__sfvwrite_small_dev+0x88>

000803a0 <_write_r>:
   803a0:	defffd04 	addi	sp,sp,-12
   803a4:	dc000015 	stw	r16,0(sp)
   803a8:	04000234 	movhi	r16,8
   803ac:	840d2104 	addi	r16,r16,13444
   803b0:	dc400115 	stw	r17,4(sp)
   803b4:	80000015 	stw	zero,0(r16)
   803b8:	2023883a 	mov	r17,r4
   803bc:	2809883a 	mov	r4,r5
   803c0:	300b883a 	mov	r5,r6
   803c4:	380d883a 	mov	r6,r7
   803c8:	dfc00215 	stw	ra,8(sp)
   803cc:	008045c0 	call	8045c <write>
   803d0:	1007883a 	mov	r3,r2
   803d4:	00bfffc4 	movi	r2,-1
   803d8:	18800626 	beq	r3,r2,803f4 <_write_r+0x54>
   803dc:	1805883a 	mov	r2,r3
   803e0:	dfc00217 	ldw	ra,8(sp)
   803e4:	dc400117 	ldw	r17,4(sp)
   803e8:	dc000017 	ldw	r16,0(sp)
   803ec:	dec00304 	addi	sp,sp,12
   803f0:	f800283a 	ret
   803f4:	80800017 	ldw	r2,0(r16)
   803f8:	103ff826 	beq	r2,zero,803dc <_write_r+0x3c>
   803fc:	88800015 	stw	r2,0(r17)
   80400:	1805883a 	mov	r2,r3
   80404:	dfc00217 	ldw	ra,8(sp)
   80408:	dc400117 	ldw	r17,4(sp)
   8040c:	dc000017 	ldw	r16,0(sp)
   80410:	dec00304 	addi	sp,sp,12
   80414:	f800283a 	ret

00080418 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   80418:	deffff04 	addi	sp,sp,-4
   8041c:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   80420:	0009883a 	mov	r4,zero
   80424:	00805bc0 	call	805bc <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   80428:	008056c0 	call	8056c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   8042c:	01800234 	movhi	r6,8
   80430:	31881e04 	addi	r6,r6,8312
   80434:	3009883a 	mov	r4,r6
   80438:	300b883a 	mov	r5,r6
   8043c:	008195c0 	call	8195c <alt_io_redirect>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   80440:	d1200e17 	ldw	r4,-32712(gp)
   80444:	d1600f17 	ldw	r5,-32708(gp)
   80448:	d1a01017 	ldw	r6,-32704(gp)
   8044c:	00801a00 	call	801a0 <main>
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   80450:	dfc00017 	ldw	ra,0(sp)
   80454:	dec00104 	addi	sp,sp,4
   80458:	f800283a 	ret

0008045c <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   8045c:	defffd04 	addi	sp,sp,-12
   80460:	dfc00215 	stw	ra,8(sp)
   80464:	dc400115 	stw	r17,4(sp)
   80468:	dc000015 	stw	r16,0(sp)
   8046c:	2821883a 	mov	r16,r5
   80470:	3023883a 	mov	r17,r6
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   80474:	20002b16 	blt	r4,zero,80524 <write+0xc8>
   80478:	01400304 	movi	r5,12
   8047c:	00820280 	call	82028 <__mulsi3>
   80480:	00c00234 	movhi	r3,8
   80484:	18ccb404 	addi	r3,r3,13008
   80488:	10c9883a 	add	r4,r2,r3
  
  if (fd)
   8048c:	20002526 	beq	r4,zero,80524 <write+0xc8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   80490:	20800217 	ldw	r2,8(r4)
   80494:	108000cc 	andi	r2,r2,3
   80498:	10001526 	beq	r2,zero,804f0 <write+0x94>
   8049c:	20800017 	ldw	r2,0(r4)
   804a0:	10800617 	ldw	r2,24(r2)
   804a4:	10001226 	beq	r2,zero,804f0 <write+0x94>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   804a8:	800b883a 	mov	r5,r16
   804ac:	880d883a 	mov	r6,r17
   804b0:	103ee83a 	callr	r2
   804b4:	1021883a 	mov	r16,r2
   804b8:	1000260e 	bge	r2,zero,80554 <write+0xf8>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   804bc:	00800234 	movhi	r2,8
   804c0:	108d1b04 	addi	r2,r2,13420
   804c4:	10800017 	ldw	r2,0(r2)
   804c8:	1000031e 	bne	r2,zero,804d8 <write+0x7c>
   804cc:	00c00234 	movhi	r3,8
   804d0:	18cd2104 	addi	r3,r3,13444
   804d4:	00000206 	br	804e0 <write+0x84>
   804d8:	103ee83a 	callr	r2
   804dc:	1007883a 	mov	r3,r2
      {
        ALT_ERRNO = -rval;
   804e0:	0405c83a 	sub	r2,zero,r16
   804e4:	18800015 	stw	r2,0(r3)
   804e8:	043fffc4 	movi	r16,-1
   804ec:	00001906 	br	80554 <write+0xf8>
   804f0:	00800234 	movhi	r2,8
   804f4:	108d1b04 	addi	r2,r2,13420
   804f8:	10800017 	ldw	r2,0(r2)
   804fc:	1000031e 	bne	r2,zero,8050c <write+0xb0>
   80500:	00c00234 	movhi	r3,8
   80504:	18cd2104 	addi	r3,r3,13444
   80508:	00000206 	br	80514 <write+0xb8>
   8050c:	103ee83a 	callr	r2
   80510:	1007883a 	mov	r3,r2
      }
      return rval;
    }
    else
    {
      ALT_ERRNO = EACCES;
   80514:	00800344 	movi	r2,13
   80518:	18800015 	stw	r2,0(r3)
   8051c:	043fffc4 	movi	r16,-1
   80520:	00000c06 	br	80554 <write+0xf8>
   80524:	00800234 	movhi	r2,8
   80528:	108d1b04 	addi	r2,r2,13420
   8052c:	10800017 	ldw	r2,0(r2)
   80530:	1000031e 	bne	r2,zero,80540 <write+0xe4>
   80534:	00c00234 	movhi	r3,8
   80538:	18cd2104 	addi	r3,r3,13444
   8053c:	00000206 	br	80548 <write+0xec>
   80540:	103ee83a 	callr	r2
   80544:	1007883a 	mov	r3,r2
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   80548:	00801444 	movi	r2,81
   8054c:	18800015 	stw	r2,0(r3)
   80550:	043fffc4 	movi	r16,-1
  }
  return -1;
}
   80554:	8005883a 	mov	r2,r16
   80558:	dfc00217 	ldw	ra,8(sp)
   8055c:	dc400117 	ldw	r17,4(sp)
   80560:	dc000017 	ldw	r16,0(sp)
   80564:	dec00304 	addi	sp,sp,12
   80568:	f800283a 	ret

0008056c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   8056c:	defffe04 	addi	sp,sp,-8
   80570:	dfc00115 	stw	ra,4(sp)
   80574:	dc000015 	stw	r16,0(sp)
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS, epcs);
   80578:	01000234 	movhi	r4,8
   8057c:	21086004 	addi	r4,r4,8576
   80580:	00809240 	call	80924 <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
   80584:	04000234 	movhi	r16,8
   80588:	84089c04 	addi	r16,r16,8816
   8058c:	8009883a 	mov	r4,r16
   80590:	000b883a 	mov	r5,zero
   80594:	01800044 	movi	r6,1
   80598:	0080c800 	call	80c80 <altera_avalon_jtag_uart_init>

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   8059c:	813ff604 	addi	r4,r16,-40
   805a0:	01400234 	movhi	r5,8
   805a4:	294d1804 	addi	r5,r5,13408
   805a8:	00816f00 	call	816f0 <alt_dev_llist_insert>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
}
   805ac:	dfc00117 	ldw	ra,4(sp)
   805b0:	dc000017 	ldw	r16,0(sp)
   805b4:	dec00204 	addi	sp,sp,8
   805b8:	f800283a 	ret

000805bc <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   805bc:	deffff04 	addi	sp,sp,-4
   805c0:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
   805c4:	0081cc00 	call	81cc0 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   805c8:	00800044 	movi	r2,1
   805cc:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   805d0:	dfc00017 	ldw	ra,0(sp)
   805d4:	dec00104 	addi	sp,sp,4
   805d8:	f800283a 	ret

000805dc <alt_epcs_flash_get_info>:
{
  int ret_code = 0;

  alt_flash_dev* flash = (alt_flash_dev*)fd;

  *number_of_regions = flash->number_of_regions;
   805dc:	20800c17 	ldw	r2,48(r4)
   805e0:	30800015 	stw	r2,0(r6)

  if (!flash->number_of_regions)
   805e4:	20c00c17 	ldw	r3,48(r4)
   805e8:	1800021e 	bne	r3,zero,805f4 <alt_epcs_flash_get_info+0x18>
   805ec:	00bffec4 	movi	r2,-5
   805f0:	f800283a 	ret
  {
    ret_code = -EIO;
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
   805f4:	00800204 	movi	r2,8
   805f8:	10c0020e 	bge	r2,r3,80604 <alt_epcs_flash_get_info+0x28>
   805fc:	00bffd04 	movi	r2,-12
   80600:	f800283a 	ret
  {
    ret_code = -ENOMEM;
  }
  else
  {
    *info = &flash->region_info[0];
   80604:	20800d04 	addi	r2,r4,52
   80608:	28800015 	stw	r2,0(r5)
   8060c:	0005883a 	mov	r2,zero
  }

  return ret_code;
}
   80610:	f800283a 	ret

00080614 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
   80614:	defffd04 	addi	sp,sp,-12
   80618:	dfc00215 	stw	ra,8(sp)
   8061c:	dc000115 	stw	r16,4(sp)
   80620:	3821883a 	mov	r16,r7
  int ret_code = 0;

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   80624:	200f883a 	mov	r7,r4
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
   80628:	013fffc4 	movi	r4,-1
   8062c:	38800c17 	ldw	r2,48(r7)
   80630:	1105883a 	add	r2,r2,r4
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
   80634:	1004913a 	slli	r2,r2,4
   80638:	11c5883a 	add	r2,r2,r7
   8063c:	10c00d17 	ldw	r3,52(r2)
   80640:	1907883a 	add	r3,r3,r4
   80644:	10800e17 	ldw	r2,56(r2)
   80648:	1887883a 	add	r3,r3,r2
   8064c:	1940022e 	bgeu	r3,r5,80658 <alt_epcs_flash_read+0x44>
   80650:	00bffec4 	movi	r2,-5
   80654:	00000706 	br	80674 <alt_epcs_flash_read+0x60>

  ret_code = alt_epcs_test_address(flash_info, offset);

  if (ret_code >= 0)
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
   80658:	39002d17 	ldw	r4,180(r7)
   8065c:	38803117 	ldw	r2,196(r7)
   80660:	d8800015 	stw	r2,0(sp)
   80664:	800f883a 	mov	r7,r16
   80668:	00815240 	call	81524 <epcs_read_buffer>
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
   8066c:	8080011e 	bne	r16,r2,80674 <alt_epcs_flash_read+0x60>
   80670:	0005883a 	mov	r2,zero
    {
      ret_code = 0;
    }
  }
  return ret_code;
}
   80674:	dfc00217 	ldw	ra,8(sp)
   80678:	dc000117 	ldw	r16,4(sp)
   8067c:	dec00304 	addi	sp,sp,12
   80680:	f800283a 	ret

00080684 <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
   80684:	defff804 	addi	sp,sp,-32
   80688:	dfc00715 	stw	ra,28(sp)
   8068c:	dd400615 	stw	r21,24(sp)
   80690:	dd000515 	stw	r20,20(sp)
   80694:	dcc00415 	stw	r19,16(sp)
   80698:	dc800315 	stw	r18,12(sp)
   8069c:	dc400215 	stw	r17,8(sp)
   806a0:	dc000115 	stw	r16,4(sp)
   806a4:	300b883a 	mov	r5,r6
   806a8:	382b883a 	mov	r21,r7
   806ac:	dc400817 	ldw	r17,32(sp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   806b0:	2025883a 	mov	r18,r4
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
   806b4:	013fffc4 	movi	r4,-1
   806b8:	90800c17 	ldw	r2,48(r18)
   806bc:	1105883a 	add	r2,r2,r4
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
   806c0:	1004913a 	slli	r2,r2,4
   806c4:	1485883a 	add	r2,r2,r18
   806c8:	10c00d17 	ldw	r3,52(r2)
   806cc:	1907883a 	add	r3,r3,r4
   806d0:	10800e17 	ldw	r2,56(r2)
   806d4:	1887883a 	add	r3,r3,r2
   806d8:	1980022e 	bgeu	r3,r6,806e4 <alt_epcs_flash_write_block+0x60>
   806dc:	00bffec4 	movi	r2,-5
   806e0:	00001506 	br	80738 <alt_epcs_flash_write_block+0xb4>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
   806e4:	88001326 	beq	r17,zero,80734 <alt_epcs_flash_write_block+0xb0>
   806e8:	0029883a 	mov	r20,zero
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
   806ec:	90803017 	ldw	r2,192(r18)
   806f0:	1147883a 	add	r3,r2,r5
   806f4:	0085c83a 	sub	r2,zero,r2
   806f8:	18a6703a 	and	r19,r3,r2
      length_of_current_write = MIN(length, next_page_start - data_offset);
   806fc:	9945c83a 	sub	r2,r19,r5
   80700:	8821883a 	mov	r16,r17
   80704:	1440010e 	bge	r2,r17,8070c <alt_epcs_flash_write_block+0x88>
   80708:	1021883a 	mov	r16,r2

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
   8070c:	91002d17 	ldw	r4,180(r18)
   80710:	90803117 	ldw	r2,196(r18)
   80714:	d8800015 	stw	r2,0(sp)
   80718:	ad0d883a 	add	r6,r21,r20
   8071c:	800f883a 	mov	r7,r16
   80720:	00814200 	call	81420 <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
   80724:	8c23c83a 	sub	r17,r17,r16
      buffer_offset += length_of_current_write;
   80728:	a429883a 	add	r20,r20,r16
   8072c:	980b883a 	mov	r5,r19
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
   80730:	883fee1e 	bne	r17,zero,806ec <alt_epcs_flash_write_block+0x68>
   80734:	0005883a 	mov	r2,zero
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
}
   80738:	dfc00717 	ldw	ra,28(sp)
   8073c:	dd400617 	ldw	r21,24(sp)
   80740:	dd000517 	ldw	r20,20(sp)
   80744:	dcc00417 	ldw	r19,16(sp)
   80748:	dc800317 	ldw	r18,12(sp)
   8074c:	dc400217 	ldw	r17,8(sp)
   80750:	dc000117 	ldw	r16,4(sp)
   80754:	dec00804 	addi	sp,sp,32
   80758:	f800283a 	ret

0008075c <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
   8075c:	deffe804 	addi	sp,sp,-96
   80760:	dfc01715 	stw	ra,92(sp)
   80764:	df001615 	stw	fp,88(sp)
   80768:	ddc01515 	stw	r23,84(sp)
   8076c:	dd801415 	stw	r22,80(sp)
   80770:	dd401315 	stw	r21,76(sp)
   80774:	dd001215 	stw	r20,72(sp)
   80778:	dcc01115 	stw	r19,68(sp)
   8077c:	dc801015 	stw	r18,64(sp)
   80780:	dc400f15 	stw	r17,60(sp)
   80784:	dc000e15 	stw	r16,56(sp)
   80788:	202b883a 	mov	r21,r4
   8078c:	2827883a 	mov	r19,r5
   80790:	d9800c15 	stw	r6,48(sp)
   80794:	d9c00d15 	stw	r7,52(sp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
   80798:	20800c17 	ldw	r2,48(r4)
   8079c:	0080510e 	bge	zero,r2,808e4 <alt_epcs_flash_write+0x188>
   807a0:	d9000915 	stw	r4,36(sp)
   807a4:	d8000b15 	stw	zero,44(sp)
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
   807a8:	df000917 	ldw	fp,36(sp)
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
   807ac:	e5000d17 	ldw	r20,52(fp)
   807b0:	9d004316 	blt	r19,r20,808c0 <alt_epcs_flash_write+0x164>
   807b4:	e0800e17 	ldw	r2,56(fp)
   807b8:	a085883a 	add	r2,r20,r2
   807bc:	9880400e 	bge	r19,r2,808c0 <alt_epcs_flash_write+0x164>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
   807c0:	e0800f17 	ldw	r2,60(fp)
   807c4:	00803e0e 	bge	zero,r2,808c0 <alt_epcs_flash_write+0x164>
   807c8:	d8000a15 	stw	zero,40(sp)
      {
        if ((offset >= current_offset ) &&
   807cc:	9d003416 	blt	r19,r20,808a0 <alt_epcs_flash_write+0x144>
   807d0:	e0801017 	ldw	r2,64(fp)
   807d4:	a085883a 	add	r2,r20,r2
   807d8:	9880310e 	bge	r19,r2,808a0 <alt_epcs_flash_write+0x144>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
   807dc:	14edc83a 	sub	r22,r2,r19
                            - offset);
          data_to_write = MIN(data_to_write, length);
   807e0:	d8800d17 	ldw	r2,52(sp)
   807e4:	1580010e 	bge	r2,r22,807ec <alt_epcs_flash_write+0x90>
   807e8:	102d883a 	mov	r22,r2
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
   807ec:	b0003f26 	beq	r22,zero,808ec <alt_epcs_flash_write+0x190>
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
                            - offset);
          data_to_write = MIN(data_to_write, length);

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
   807f0:	b023883a 	mov	r17,r22
   807f4:	0025883a 	mov	r18,zero
   807f8:	05c00804 	movi	r23,32
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
   807fc:	8821883a 	mov	r16,r17
   80800:	bc40012e 	bgeu	r23,r17,80808 <alt_epcs_flash_write+0xac>
   80804:	b821883a 	mov	r16,r23
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
   80808:	a809883a 	mov	r4,r21
   8080c:	9c8b883a 	add	r5,r19,r18
   80810:	d9800104 	addi	r6,sp,4
   80814:	800f883a 	mov	r7,r16
   80818:	00806140 	call	80614 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
   8081c:	10000a16 	blt	r2,zero,80848 <alt_epcs_flash_write+0xec>
      */
      return -1;
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
   80820:	d8c00c17 	ldw	r3,48(sp)
   80824:	1c89883a 	add	r4,r3,r18
   80828:	d9400104 	addi	r5,sp,4
   8082c:	800d883a 	mov	r6,r16
   80830:	0081fc00 	call	81fc0 <memcmp>
   80834:	1000041e 	bne	r2,zero,80848 <alt_epcs_flash_write+0xec>
    if (this_chunk_cmp)
    {
      return this_chunk_cmp;
    }

    n -= this_chunk_size;
   80838:	8c23c83a 	sub	r17,r17,r16
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
   8083c:	88002b26 	beq	r17,zero,808ec <alt_epcs_flash_write+0x190>
    {
      return this_chunk_cmp;
    }

    n -= this_chunk_size;
    current_offset += this_chunk_size;
   80840:	9425883a 	add	r18,r18,r16
   80844:	003fed06 	br	807fc <alt_epcs_flash_write+0xa0>
                            - offset);
          data_to_write = MIN(data_to_write, length);

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
   80848:	a8800817 	ldw	r2,32(r21)
   8084c:	a809883a 	mov	r4,r21
   80850:	a00b883a 	mov	r5,r20
   80854:	103ee83a 	callr	r2

            if (!ret_code)
   80858:	1000071e 	bne	r2,zero,80878 <alt_epcs_flash_write+0x11c>
            {
              ret_code = (*flash_info->write_block)(
   8085c:	dd800015 	stw	r22,0(sp)
   80860:	a8800917 	ldw	r2,36(r21)
   80864:	a809883a 	mov	r4,r21
   80868:	a00b883a 	mov	r5,r20
   8086c:	980d883a 	mov	r6,r19
   80870:	d9c00c17 	ldw	r7,48(sp)
   80874:	103ee83a 	callr	r2
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
   80878:	d9000d17 	ldw	r4,52(sp)
   8087c:	b1001d26 	beq	r22,r4,808f4 <alt_epcs_flash_write+0x198>
   80880:	10001c1e 	bne	r2,zero,808f4 <alt_epcs_flash_write+0x198>
          {
            goto finished;
          }

          length -= data_to_write;
   80884:	2589c83a 	sub	r4,r4,r22
   80888:	d9000d15 	stw	r4,52(sp)
          offset = current_offset + flash_info->region_info[i].block_size;
   8088c:	e0801017 	ldw	r2,64(fp)
   80890:	a0a7883a 	add	r19,r20,r2
          src_addr = (alt_u8*)src_addr + data_to_write;
   80894:	d8800c17 	ldw	r2,48(sp)
   80898:	1585883a 	add	r2,r2,r22
   8089c:	d8800c15 	stw	r2,48(sp)
        }
        current_offset += flash_info->region_info[i].block_size;
   808a0:	e0c01017 	ldw	r3,64(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
   808a4:	d9000a17 	ldw	r4,40(sp)
   808a8:	21000044 	addi	r4,r4,1
   808ac:	d9000a15 	stw	r4,40(sp)
   808b0:	e0800f17 	ldw	r2,60(fp)
   808b4:	2080020e 	bge	r4,r2,808c0 <alt_epcs_flash_write+0x164>

          length -= data_to_write;
          offset = current_offset + flash_info->region_info[i].block_size;
          src_addr = (alt_u8*)src_addr + data_to_write;
        }
        current_offset += flash_info->region_info[i].block_size;
   808b8:	a0e9883a 	add	r20,r20,r3
   808bc:	003fc306 	br	807cc <alt_epcs_flash_write+0x70>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
   808c0:	d8800b17 	ldw	r2,44(sp)
   808c4:	10800044 	addi	r2,r2,1
   808c8:	d8800b15 	stw	r2,44(sp)
   808cc:	d8c00917 	ldw	r3,36(sp)
   808d0:	18c00404 	addi	r3,r3,16
   808d4:	d8c00915 	stw	r3,36(sp)
   808d8:	a8800c17 	ldw	r2,48(r21)
   808dc:	d9000b17 	ldw	r4,44(sp)
   808e0:	20bfb116 	blt	r4,r2,807a8 <alt_epcs_flash_write+0x4c>
        current_offset += flash_info->region_info[i].block_size;
      }
    }
  }

finished:
   808e4:	0005883a 	mov	r2,zero
   808e8:	00000206 	br	808f4 <alt_epcs_flash_write+0x198>
   808ec:	0005883a 	mov	r2,zero
   808f0:	003fe106 	br	80878 <alt_epcs_flash_write+0x11c>
  return ret_code;
}
   808f4:	dfc01717 	ldw	ra,92(sp)
   808f8:	df001617 	ldw	fp,88(sp)
   808fc:	ddc01517 	ldw	r23,84(sp)
   80900:	dd801417 	ldw	r22,80(sp)
   80904:	dd401317 	ldw	r21,76(sp)
   80908:	dd001217 	ldw	r20,72(sp)
   8090c:	dcc01117 	ldw	r19,68(sp)
   80910:	dc801017 	ldw	r18,64(sp)
   80914:	dc400f17 	ldw	r17,60(sp)
   80918:	dc000e17 	ldw	r16,56(sp)
   8091c:	dec01804 	addi	sp,sp,96
   80920:	f800283a 	ret

00080924 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
   80924:	defffe04 	addi	sp,sp,-8
   80928:	dfc00115 	stw	ra,4(sp)
   8092c:	dc000015 	stw	r16,0(sp)
   80930:	2021883a 	mov	r16,r4
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
   80934:	20003115 	stw	zero,196(r4)
  
  /* Send the RES command sequence */
  flash->silicon_id =
   80938:	21002d17 	ldw	r4,180(r4)
   8093c:	00811ec0 	call	811ec <epcs_read_electronic_signature>
   80940:	1009883a 	mov	r4,r2
   80944:	10c03fcc 	andi	r3,r2,255
   80948:	80c02f15 	stw	r3,188(r16)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
   8094c:	00800584 	movi	r2,22
   80950:	1880071e 	bne	r3,r2,80970 <alt_epcs_flash_init+0x4c>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
   80954:	00802034 	movhi	r2,128
   80958:	80800e15 	stw	r2,56(r16)
    flash->dev.region_info[0].number_of_blocks = 128;
   8095c:	00802004 	movi	r2,128
   80960:	80800f15 	stw	r2,60(r16)
    flash->dev.region_info[0].block_size = 65536;
   80964:	00800074 	movhi	r2,1
   80968:	80801015 	stw	r2,64(r16)
   8096c:	00004d06 	br	80aa4 <alt_epcs_flash_init+0x180>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
   80970:	20c03fcc 	andi	r3,r4,255
   80974:	00800504 	movi	r2,20
   80978:	1880071e 	bne	r3,r2,80998 <alt_epcs_flash_init+0x74>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
   8097c:	00800834 	movhi	r2,32
   80980:	80800e15 	stw	r2,56(r16)
    flash->dev.region_info[0].number_of_blocks = 32;
   80984:	00800804 	movi	r2,32
   80988:	80800f15 	stw	r2,60(r16)
    flash->dev.region_info[0].block_size = 65536;
   8098c:	00800074 	movhi	r2,1
   80990:	80801015 	stw	r2,64(r16)
   80994:	00004306 	br	80aa4 <alt_epcs_flash_init+0x180>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
   80998:	20c03fcc 	andi	r3,r4,255
   8099c:	008004c4 	movi	r2,19
   809a0:	1880071e 	bne	r3,r2,809c0 <alt_epcs_flash_init+0x9c>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
   809a4:	00800434 	movhi	r2,16
   809a8:	80800e15 	stw	r2,56(r16)
    flash->dev.region_info[0].number_of_blocks = 16;
   809ac:	00800404 	movi	r2,16
   809b0:	80800f15 	stw	r2,60(r16)
    flash->dev.region_info[0].block_size = 65536;
   809b4:	00800074 	movhi	r2,1
   809b8:	80801015 	stw	r2,64(r16)
   809bc:	00003906 	br	80aa4 <alt_epcs_flash_init+0x180>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
   809c0:	20c03fcc 	andi	r3,r4,255
   809c4:	00800484 	movi	r2,18
   809c8:	1880071e 	bne	r3,r2,809e8 <alt_epcs_flash_init+0xc4>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
   809cc:	00800234 	movhi	r2,8
   809d0:	80800e15 	stw	r2,56(r16)
    flash->dev.region_info[0].number_of_blocks = 8;
   809d4:	00800204 	movi	r2,8
   809d8:	80800f15 	stw	r2,60(r16)
    flash->dev.region_info[0].block_size = 65536;
   809dc:	00800074 	movhi	r2,1
   809e0:	80801015 	stw	r2,64(r16)
   809e4:	00002f06 	br	80aa4 <alt_epcs_flash_init+0x180>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
   809e8:	20c03fcc 	andi	r3,r4,255
   809ec:	00800404 	movi	r2,16
   809f0:	1880071e 	bne	r3,r2,80a10 <alt_epcs_flash_init+0xec>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
   809f4:	008000b4 	movhi	r2,2
   809f8:	80800e15 	stw	r2,56(r16)
    flash->dev.region_info[0].number_of_blocks = 4;
   809fc:	00800104 	movi	r2,4
   80a00:	80800f15 	stw	r2,60(r16)
    flash->dev.region_info[0].block_size = 32768;
   80a04:	00a00014 	movui	r2,32768
   80a08:	80801015 	stw	r2,64(r16)
   80a0c:	00002506 	br	80aa4 <alt_epcs_flash_init+0x180>
  {
    /* 
     * Read electronic signature doesn't work for the EPCS128; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
   80a10:	81002d17 	ldw	r4,180(r16)
   80a14:	008118c0 	call	8118c <epcs_read_device_id>
   80a18:	1009883a 	mov	r4,r2
   80a1c:	80802f15 	stw	r2,188(r16)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
   80a20:	00804034 	movhi	r2,256
   80a24:	10bfffc4 	addi	r2,r2,-1
   80a28:	2084703a 	and	r2,r4,r2
   80a2c:	00c00874 	movhi	r3,33
   80a30:	18ee8604 	addi	r3,r3,-17896
   80a34:	10c0071e 	bne	r2,r3,80a54 <alt_epcs_flash_init+0x130>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
   80a38:	00804034 	movhi	r2,256
   80a3c:	80800e15 	stw	r2,56(r16)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
   80a40:	00804004 	movi	r2,256
   80a44:	80800f15 	stw	r2,60(r16)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   80a48:	00800074 	movhi	r2,1
   80a4c:	80801015 	stw	r2,64(r16)
   80a50:	00001406 	br	80aa4 <alt_epcs_flash_init+0x180>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
   80a54:	20c03fcc 	andi	r3,r4,255
   80a58:	00800604 	movi	r2,24
   80a5c:	1880071e 	bne	r3,r2,80a7c <alt_epcs_flash_init+0x158>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
   80a60:	00804034 	movhi	r2,256
   80a64:	80800e15 	stw	r2,56(r16)
      flash->dev.region_info[0].number_of_blocks = 64;
   80a68:	00801004 	movi	r2,64
   80a6c:	80800f15 	stw	r2,60(r16)
      flash->dev.region_info[0].block_size = 262144;
   80a70:	00800134 	movhi	r2,4
   80a74:	80801015 	stw	r2,64(r16)
   80a78:	00000a06 	br	80aa4 <alt_epcs_flash_init+0x180>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
   80a7c:	00800644 	movi	r2,25
   80a80:	1880141e 	bne	r3,r2,80ad4 <alt_epcs_flash_init+0x1b0>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
   80a84:	00808034 	movhi	r2,512
   80a88:	80800e15 	stw	r2,56(r16)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
   80a8c:	00808004 	movi	r2,512
   80a90:	80800f15 	stw	r2,60(r16)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
   80a94:	00800074 	movhi	r2,1
   80a98:	80801015 	stw	r2,64(r16)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
   80a9c:	00800044 	movi	r2,1
   80aa0:	80803115 	stw	r2,196(r16)
    {
      ret_code = -ENODEV; /* No known device found! */
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
   80aa4:	80800e17 	ldw	r2,56(r16)
   80aa8:	80802e15 	stw	r2,184(r16)
  flash->dev.number_of_regions = 1;
   80aac:	00800044 	movi	r2,1
   80ab0:	80800c15 	stw	r2,48(r16)
  flash->dev.region_info[0].offset = 0;
   80ab4:	80000d15 	stw	zero,52(r16)
  flash->page_size = 256;
   80ab8:	00804004 	movi	r2,256
   80abc:	80803015 	stw	r2,192(r16)

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
   80ac0:	8009883a 	mov	r4,r16
   80ac4:	01400234 	movhi	r5,8
   80ac8:	294d1c04 	addi	r5,r5,13424
   80acc:	00816f00 	call	816f0 <alt_dev_llist_insert>
   80ad0:	00000806 	br	80af4 <alt_epcs_flash_init+0x1d0>
    {
      ret_code = -ENODEV; /* No known device found! */
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
   80ad4:	80800e17 	ldw	r2,56(r16)
   80ad8:	80802e15 	stw	r2,184(r16)
  flash->dev.number_of_regions = 1;
   80adc:	00800044 	movi	r2,1
   80ae0:	80800c15 	stw	r2,48(r16)
  flash->dev.region_info[0].offset = 0;
   80ae4:	80000d15 	stw	zero,52(r16)
  flash->page_size = 256;
   80ae8:	00804004 	movi	r2,256
   80aec:	80803015 	stw	r2,192(r16)
   80af0:	00bffb44 	movi	r2,-19
  */
  if (!ret_code)
    ret_code = alt_flash_device_register(&(flash->dev));

  return ret_code;
}
   80af4:	dfc00117 	ldw	ra,4(sp)
   80af8:	dc000017 	ldw	r16,0(sp)
   80afc:	dec00204 	addi	sp,sp,8
   80b00:	f800283a 	ret

00080b04 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
   80b04:	deffff04 	addi	sp,sp,-4
   80b08:	dfc00015 	stw	ra,0(sp)
  int ret_code = 0;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
   80b0c:	200d883a 	mov	r6,r4
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
   80b10:	013fffc4 	movi	r4,-1
   80b14:	30800c17 	ldw	r2,48(r6)
   80b18:	1105883a 	add	r2,r2,r4
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
   80b1c:	1004913a 	slli	r2,r2,4
   80b20:	1185883a 	add	r2,r2,r6
   80b24:	10c00d17 	ldw	r3,52(r2)
   80b28:	1907883a 	add	r3,r3,r4
   80b2c:	10800e17 	ldw	r2,56(r2)
   80b30:	1887883a 	add	r3,r3,r2
   80b34:	1940022e 	bgeu	r3,r5,80b40 <alt_epcs_flash_erase_block+0x3c>
   80b38:	00bffec4 	movi	r2,-5
   80b3c:	00000406 	br	80b50 <alt_epcs_flash_erase_block+0x4c>
  if (ret_code >= 0)
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
   80b40:	31002d17 	ldw	r4,180(r6)
   80b44:	31803117 	ldw	r6,196(r6)
   80b48:	00813540 	call	81354 <epcs_sector_erase>
   80b4c:	0005883a 	mov	r2,zero
  }
  return ret_code;
}
   80b50:	dfc00017 	ldw	ra,0(sp)
   80b54:	dec00104 	addi	sp,sp,4
   80b58:	f800283a 	ret

00080b5c <altera_avalon_jtag_uart_ioctl_fd>:
    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
}

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   80b5c:	deffff04 	addi	sp,sp,-4
   80b60:	dfc00015 	stw	ra,0(sp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   80b64:	21000017 	ldw	r4,0(r4)
   80b68:	21000a04 	addi	r4,r4,40
   80b6c:	0080e340 	call	80e34 <altera_avalon_jtag_uart_ioctl>
}
   80b70:	dfc00017 	ldw	ra,0(sp)
   80b74:	dec00104 	addi	sp,sp,4
   80b78:	f800283a 	ret

00080b7c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   80b7c:	deffff04 	addi	sp,sp,-4
   80b80:	dfc00015 	stw	ra,0(sp)
   80b84:	2005883a 	mov	r2,r4
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   80b88:	21000017 	ldw	r4,0(r4)
   80b8c:	21000a04 	addi	r4,r4,40
   80b90:	11400217 	ldw	r5,8(r2)
   80b94:	0080bf40 	call	80bf4 <altera_avalon_jtag_uart_close>
}
   80b98:	dfc00017 	ldw	ra,0(sp)
   80b9c:	dec00104 	addi	sp,sp,4
   80ba0:	f800283a 	ret

00080ba4 <altera_avalon_jtag_uart_write_fd>:
      fd->fd_flags);
}

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   80ba4:	deffff04 	addi	sp,sp,-4
   80ba8:	dfc00015 	stw	ra,0(sp)
   80bac:	2005883a 	mov	r2,r4
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   80bb0:	21000017 	ldw	r4,0(r4)
   80bb4:	21000a04 	addi	r4,r4,40
   80bb8:	11c00217 	ldw	r7,8(r2)
   80bbc:	00810100 	call	81010 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   80bc0:	dfc00017 	ldw	ra,0(sp)
   80bc4:	dec00104 	addi	sp,sp,4
   80bc8:	f800283a 	ret

00080bcc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   80bcc:	deffff04 	addi	sp,sp,-4
   80bd0:	dfc00015 	stw	ra,0(sp)
   80bd4:	2005883a 	mov	r2,r4
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   80bd8:	21000017 	ldw	r4,0(r4)
   80bdc:	21000a04 	addi	r4,r4,40
   80be0:	11c00217 	ldw	r7,8(r2)
   80be4:	0080ea80 	call	80ea8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   80be8:	dfc00017 	ldw	ra,0(sp)
   80bec:	dec00104 	addi	sp,sp,4
   80bf0:	f800283a 	ret

00080bf4 <altera_avalon_jtag_uart_close>:
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   80bf4:	21800c17 	ldw	r6,48(r4)
   80bf8:	2950000c 	andi	r5,r5,16384
   80bfc:	280b003a 	cmpeq	r5,r5,zero
   80c00:	00000306 	br	80c10 <altera_avalon_jtag_uart_close+0x1c>
    if (flags & O_NONBLOCK) {
   80c04:	2800021e 	bne	r5,zero,80c10 <altera_avalon_jtag_uart_close+0x1c>
   80c08:	00bffd44 	movi	r2,-11
   80c0c:	f800283a 	ret
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   80c10:	20800d17 	ldw	r2,52(r4)
   80c14:	11800326 	beq	r2,r6,80c24 <altera_avalon_jtag_uart_close+0x30>
   80c18:	20c00917 	ldw	r3,36(r4)
   80c1c:	20800117 	ldw	r2,4(r4)
   80c20:	18bff836 	bltu	r3,r2,80c04 <altera_avalon_jtag_uart_close+0x10>
   80c24:	0005883a 	mov	r2,zero
      return -EWOULDBLOCK; 
    }
  }

  return 0;
}
   80c28:	f800283a 	ret

00080c2c <altera_avalon_jtag_uart_timeout>:
static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   80c2c:	20800017 	ldw	r2,0(r4)
   80c30:	10c00104 	addi	r3,r2,4
   80c34:	18800037 	ldwio	r2,0(r3)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   80c38:	01410004 	movi	r5,1024
   80c3c:	1144703a 	and	r2,r2,r5
   80c40:	10000526 	beq	r2,zero,80c58 <altera_avalon_jtag_uart_timeout+0x2c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   80c44:	20800817 	ldw	r2,32(r4)
   80c48:	1144b03a 	or	r2,r2,r5
   80c4c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
   80c50:	20000915 	stw	zero,36(r4)
   80c54:	00000606 	br	80c70 <altera_avalon_jtag_uart_timeout+0x44>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   80c58:	20c00917 	ldw	r3,36(r4)
   80c5c:	00a00034 	movhi	r2,32768
   80c60:	10bfff04 	addi	r2,r2,-4
   80c64:	10c00236 	bltu	r2,r3,80c70 <altera_avalon_jtag_uart_timeout+0x44>
    sp->host_inactive++;
   80c68:	18800044 	addi	r2,r3,1
   80c6c:	20800915 	stw	r2,36(r4)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   80c70:	00800234 	movhi	r2,8
   80c74:	108d2604 	addi	r2,r2,13464
   80c78:	10800017 	ldw	r2,0(r2)
   80c7c:	f800283a 	ret

00080c80 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   80c80:	defffd04 	addi	sp,sp,-12
   80c84:	dfc00215 	stw	ra,8(sp)
   80c88:	dc000115 	stw	r16,4(sp)
   80c8c:	2021883a 	mov	r16,r4
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   80c90:	00c00044 	movi	r3,1
   80c94:	20c00815 	stw	r3,32(r4)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   80c98:	20800017 	ldw	r2,0(r4)
   80c9c:	10c00135 	stwio	r3,4(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   80ca0:	d8000015 	stw	zero,0(sp)
   80ca4:	2809883a 	mov	r4,r5
   80ca8:	300b883a 	mov	r5,r6
   80cac:	01800234 	movhi	r6,8
   80cb0:	31834004 	addi	r6,r6,3328
   80cb4:	800f883a 	mov	r7,r16
   80cb8:	008185c0 	call	8185c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   80cbc:	80000915 	stw	zero,36(r16)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   80cc0:	81000204 	addi	r4,r16,8
   80cc4:	00800234 	movhi	r2,8
   80cc8:	108d2604 	addi	r2,r2,13464
   80ccc:	11400017 	ldw	r5,0(r2)
   80cd0:	01800234 	movhi	r6,8
   80cd4:	31830b04 	addi	r6,r6,3116
   80cd8:	800f883a 	mov	r7,r16
   80cdc:	00816540 	call	81654 <alt_alarm_start>
   80ce0:	1000030e 	bge	r2,zero,80cf0 <altera_avalon_jtag_uart_init+0x70>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   80ce4:	00a00034 	movhi	r2,32768
   80ce8:	10bfffc4 	addi	r2,r2,-1
   80cec:	80800115 	stw	r2,4(r16)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   80cf0:	dfc00217 	ldw	ra,8(sp)
   80cf4:	dc000117 	ldw	r16,4(sp)
   80cf8:	dec00304 	addi	sp,sp,12
   80cfc:	f800283a 	ret

00080d00 <altera_avalon_jtag_uart_irq>:
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  unsigned int base = sp->base;
   80d00:	22000017 	ldw	r8,0(r4)
   80d04:	03800104 	movi	r14,4
   80d08:	4399883a 	add	r12,r8,r14
   80d0c:	037ffff4 	movhi	r13,65535
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   80d10:	62c00037 	ldwio	r11,0(r12)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   80d14:	5880c00c 	andi	r2,r11,768
   80d18:	10004526 	beq	r2,zero,80e30 <altera_avalon_jtag_uart_irq+0x130>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   80d1c:	5880400c 	andi	r2,r11,256
   80d20:	10002126 	beq	r2,zero,80da8 <altera_avalon_jtag_uart_irq+0xa8>
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   80d24:	20800a17 	ldw	r2,40(r4)
        if (next == sp->rx_out)
   80d28:	10800044 	addi	r2,r2,1
   80d2c:	1081ffcc 	andi	r2,r2,2047
   80d30:	20c00b17 	ldw	r3,44(r4)
   80d34:	10c01626 	beq	r2,r3,80d90 <altera_avalon_jtag_uart_irq+0x90>
   80d38:	02a00014 	movui	r10,32768
   80d3c:	02400e04 	movi	r9,56
   80d40:	01c00044 	movi	r7,1
   80d44:	0181ffc4 	movi	r6,2047
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   80d48:	41400037 	ldwio	r5,0(r8)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   80d4c:	2a84703a 	and	r2,r5,r10
   80d50:	10000d26 	beq	r2,zero,80d88 <altera_avalon_jtag_uart_irq+0x88>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   80d54:	20800a17 	ldw	r2,40(r4)
   80d58:	1105883a 	add	r2,r2,r4
   80d5c:	1245883a 	add	r2,r2,r9
   80d60:	11400005 	stb	r5,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   80d64:	20800a17 	ldw	r2,40(r4)
   80d68:	11c5883a 	add	r2,r2,r7
   80d6c:	1184703a 	and	r2,r2,r6
   80d70:	20800a15 	stw	r2,40(r4)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   80d74:	20800a17 	ldw	r2,40(r4)
        if (next == sp->rx_out)
   80d78:	11c5883a 	add	r2,r2,r7
   80d7c:	1184703a 	and	r2,r2,r6
   80d80:	20c00b17 	ldw	r3,44(r4)
   80d84:	10fff01e 	bne	r2,r3,80d48 <altera_avalon_jtag_uart_irq+0x48>

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   80d88:	2b44703a 	and	r2,r5,r13
   80d8c:	10000626 	beq	r2,zero,80da8 <altera_avalon_jtag_uart_irq+0xa8>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   80d90:	20800817 	ldw	r2,32(r4)
   80d94:	00ffff84 	movi	r3,-2
   80d98:	10c4703a 	and	r2,r2,r3
   80d9c:	20800815 	stw	r2,32(r4)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   80da0:	60800035 	stwio	r2,0(r12)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   80da4:	60800037 	ldwio	r2,0(r12)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   80da8:	5880800c 	andi	r2,r11,512
   80dac:	103fd826 	beq	r2,zero,80d10 <altera_avalon_jtag_uart_irq+0x10>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   80db0:	5b44703a 	and	r2,r11,r13
   80db4:	100ad43a 	srli	r5,r2,16

      while (space > 0 && sp->tx_out != sp->tx_in)
   80db8:	283fd526 	beq	r5,zero,80d10 <altera_avalon_jtag_uart_irq+0x10>
   80dbc:	20c00d17 	ldw	r3,52(r4)
   80dc0:	20800c17 	ldw	r2,48(r4)
   80dc4:	18801126 	beq	r3,r2,80e0c <altera_avalon_jtag_uart_irq+0x10c>
   80dc8:	02420e04 	movi	r9,2104
   80dcc:	01800044 	movi	r6,1
   80dd0:	01c1ffc4 	movi	r7,2047
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   80dd4:	20800d17 	ldw	r2,52(r4)
   80dd8:	1105883a 	add	r2,r2,r4
   80ddc:	1245883a 	add	r2,r2,r9
   80de0:	10800007 	ldb	r2,0(r2)
   80de4:	40800035 	stwio	r2,0(r8)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   80de8:	20800d17 	ldw	r2,52(r4)
   80dec:	1185883a 	add	r2,r2,r6
   80df0:	11c4703a 	and	r2,r2,r7
   80df4:	20800d15 	stw	r2,52(r4)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   80df8:	298bc83a 	sub	r5,r5,r6
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   80dfc:	283fc426 	beq	r5,zero,80d10 <altera_avalon_jtag_uart_irq+0x10>
   80e00:	20c00d17 	ldw	r3,52(r4)
   80e04:	20800c17 	ldw	r2,48(r4)
   80e08:	18bff21e 	bne	r3,r2,80dd4 <altera_avalon_jtag_uart_irq+0xd4>
      }

      if (space > 0)
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   80e0c:	20c00817 	ldw	r3,32(r4)
   80e10:	00bfff44 	movi	r2,-3
   80e14:	1886703a 	and	r3,r3,r2
   80e18:	20c00815 	stw	r3,32(r4)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   80e1c:	20800017 	ldw	r2,0(r4)
   80e20:	1385883a 	add	r2,r2,r14
   80e24:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   80e28:	60800037 	ldwio	r2,0(r12)
   80e2c:	003fb806 	br	80d10 <altera_avalon_jtag_uart_irq+0x10>
   80e30:	f800283a 	ret

00080e34 <altera_avalon_jtag_uart_ioctl>:
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  int rc = -ENOTTY;

  switch (req)
   80e34:	009a8044 	movi	r2,27137
   80e38:	28800326 	beq	r5,r2,80e48 <altera_avalon_jtag_uart_ioctl+0x14>
   80e3c:	009a8084 	movi	r2,27138
   80e40:	2880171e 	bne	r5,r2,80ea0 <altera_avalon_jtag_uart_ioctl+0x6c>
   80e44:	00000d06 	br	80e7c <altera_avalon_jtag_uart_ioctl+0x48>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   80e48:	20c00117 	ldw	r3,4(r4)
   80e4c:	00a00034 	movhi	r2,32768
   80e50:	10bfffc4 	addi	r2,r2,-1
   80e54:	18801226 	beq	r3,r2,80ea0 <altera_avalon_jtag_uart_ioctl+0x6c>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   80e58:	31800017 	ldw	r6,0(r6)
   80e5c:	30ffff84 	addi	r3,r6,-2
   80e60:	10bfff44 	addi	r2,r2,-3
   80e64:	10c0022e 	bgeu	r2,r3,80e70 <altera_avalon_jtag_uart_ioctl+0x3c>
   80e68:	01a00034 	movhi	r6,32768
   80e6c:	31bfff84 	addi	r6,r6,-2
   80e70:	21800115 	stw	r6,4(r4)
   80e74:	0005883a 	mov	r2,zero
   80e78:	f800283a 	ret
    }
    break;

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   80e7c:	20c00117 	ldw	r3,4(r4)
   80e80:	00a00034 	movhi	r2,32768
   80e84:	10bfffc4 	addi	r2,r2,-1
   80e88:	18800526 	beq	r3,r2,80ea0 <altera_avalon_jtag_uart_ioctl+0x6c>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   80e8c:	20800917 	ldw	r2,36(r4)
   80e90:	10c5803a 	cmpltu	r2,r2,r3
   80e94:	30800015 	stw	r2,0(r6)
   80e98:	0005883a 	mov	r2,zero
   80e9c:	f800283a 	ret
   80ea0:	00bff9c4 	movi	r2,-25
  default:
    break;
  }

  return rc;
}
   80ea4:	f800283a 	ret

00080ea8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   80ea8:	defff604 	addi	sp,sp,-40
   80eac:	dfc00915 	stw	ra,36(sp)
   80eb0:	df000815 	stw	fp,32(sp)
   80eb4:	ddc00715 	stw	r23,28(sp)
   80eb8:	dd800615 	stw	r22,24(sp)
   80ebc:	dd400515 	stw	r21,20(sp)
   80ec0:	dd000415 	stw	r20,16(sp)
   80ec4:	dcc00315 	stw	r19,12(sp)
   80ec8:	dc800215 	stw	r18,8(sp)
   80ecc:	dc400115 	stw	r17,4(sp)
   80ed0:	dc000015 	stw	r16,0(sp)
   80ed4:	2025883a 	mov	r18,r4
   80ed8:	282f883a 	mov	r23,r5
   80edc:	3027883a 	mov	r19,r6
   80ee0:	3839883a 	mov	fp,r7
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   80ee4:	0180220e 	bge	zero,r6,80f70 <altera_avalon_jtag_uart_read+0xc8>
   80ee8:	b82b883a 	mov	r21,r23
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   80eec:	95800a17 	ldw	r22,40(r18)
      out = sp->rx_out;
   80ef0:	94400b17 	ldw	r17,44(r18)

      if (in >= out)
   80ef4:	b4400236 	bltu	r22,r17,80f00 <altera_avalon_jtag_uart_read+0x58>
        n = in - out;
   80ef8:	b461c83a 	sub	r16,r22,r17
   80efc:	00000206 	br	80f08 <altera_avalon_jtag_uart_read+0x60>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   80f00:	00820004 	movi	r2,2048
   80f04:	1461c83a 	sub	r16,r2,r17

      if (n == 0)
   80f08:	80000d26 	beq	r16,zero,80f40 <altera_avalon_jtag_uart_read+0x98>
        break; /* No more data available */

      if (n > space)
   80f0c:	9829883a 	mov	r20,r19
   80f10:	9c001d36 	bltu	r19,r16,80f88 <altera_avalon_jtag_uart_read+0xe0>
        n = space;

      memcpy(ptr, sp->rx_buf + out, n);
   80f14:	91400e04 	addi	r5,r18,56
   80f18:	a809883a 	mov	r4,r21
   80f1c:	2c4b883a 	add	r5,r5,r17
   80f20:	800d883a 	mov	r6,r16
   80f24:	0081ffc0 	call	81ffc <memcpy>
      ptr   += n;
   80f28:	ac2b883a 	add	r21,r21,r16
      space -= n;
   80f2c:	9c27c83a 	sub	r19,r19,r16

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   80f30:	8445883a 	add	r2,r16,r17
   80f34:	1081ffcc 	andi	r2,r2,2047
   80f38:	90800b15 	stw	r2,44(r18)
    }
    while (space > 0);
   80f3c:	04ffeb16 	blt	zero,r19,80eec <altera_avalon_jtag_uart_read+0x44>

    /* If we read any data then return it */
    if (ptr != buffer)
   80f40:	adc01c1e 	bne	r21,r23,80fb4 <altera_avalon_jtag_uart_read+0x10c>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   80f44:	e090000c 	andi	r2,fp,16384
   80f48:	10000d1e 	bne	r2,zero,80f80 <altera_avalon_jtag_uart_read+0xd8>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   80f4c:	90800a17 	ldw	r2,40(r18)
   80f50:	b080031e 	bne	r22,r2,80f60 <altera_avalon_jtag_uart_read+0xb8>
   80f54:	90c00917 	ldw	r3,36(r18)
   80f58:	90800117 	ldw	r2,4(r18)
   80f5c:	18bffb36 	bltu	r3,r2,80f4c <altera_avalon_jtag_uart_read+0xa4>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   80f60:	90800a17 	ldw	r2,40(r18)
   80f64:	b0800426 	beq	r22,r2,80f78 <altera_avalon_jtag_uart_read+0xd0>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   80f68:	04c0030e 	bge	zero,r19,80f78 <altera_avalon_jtag_uart_read+0xd0>
   80f6c:	003fde06 	br	80ee8 <altera_avalon_jtag_uart_read+0x40>
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
    return ptr - buffer;
  else if (flags & O_NONBLOCK)
   80f70:	3890000c 	andi	r2,r7,16384
   80f74:	1000021e 	bne	r2,zero,80f80 <altera_avalon_jtag_uart_read+0xd8>
   80f78:	00bffec4 	movi	r2,-5
   80f7c:	00001806 	br	80fe0 <altera_avalon_jtag_uart_read+0x138>
   80f80:	00bffd44 	movi	r2,-11
   80f84:	00001606 	br	80fe0 <altera_avalon_jtag_uart_read+0x138>
        break; /* No more data available */

      if (n > space)
        n = space;

      memcpy(ptr, sp->rx_buf + out, n);
   80f88:	91400e04 	addi	r5,r18,56
   80f8c:	a809883a 	mov	r4,r21
   80f90:	894b883a 	add	r5,r17,r5
   80f94:	980d883a 	mov	r6,r19
   80f98:	0081ffc0 	call	81ffc <memcpy>
      ptr   += n;
   80f9c:	aceb883a 	add	r21,r21,r19
      space -= n;
   80fa0:	0027883a 	mov	r19,zero

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   80fa4:	a445883a 	add	r2,r20,r17
   80fa8:	1081ffcc 	andi	r2,r2,2047
   80fac:	90800b15 	stw	r2,44(r18)
   80fb0:	003fe306 	br	80f40 <altera_avalon_jtag_uart_read+0x98>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   80fb4:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   80fb8:	00bfff84 	movi	r2,-2
   80fbc:	2084703a 	and	r2,r4,r2
   80fc0:	1001703a 	wrctl	status,r2

  if (ptr != buffer)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   80fc4:	90800817 	ldw	r2,32(r18)
   80fc8:	10800054 	ori	r2,r2,1
   80fcc:	90800815 	stw	r2,32(r18)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   80fd0:	90c00017 	ldw	r3,0(r18)
   80fd4:	18800135 	stwio	r2,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   80fd8:	2001703a 	wrctl	status,r4
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
    return ptr - buffer;
   80fdc:	adc5c83a 	sub	r2,r21,r23
  else if (flags & O_NONBLOCK)
    return -EWOULDBLOCK;
  else
    return -EIO;
}
   80fe0:	dfc00917 	ldw	ra,36(sp)
   80fe4:	df000817 	ldw	fp,32(sp)
   80fe8:	ddc00717 	ldw	r23,28(sp)
   80fec:	dd800617 	ldw	r22,24(sp)
   80ff0:	dd400517 	ldw	r21,20(sp)
   80ff4:	dd000417 	ldw	r20,16(sp)
   80ff8:	dcc00317 	ldw	r19,12(sp)
   80ffc:	dc800217 	ldw	r18,8(sp)
   81000:	dc400117 	ldw	r17,4(sp)
   81004:	dc000017 	ldw	r16,0(sp)
   81008:	dec00a04 	addi	sp,sp,40
   8100c:	f800283a 	ret

00081010 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   81010:	defff804 	addi	sp,sp,-32
   81014:	dfc00715 	stw	ra,28(sp)
   81018:	dd800615 	stw	r22,24(sp)
   8101c:	dd400515 	stw	r21,20(sp)
   81020:	dd000415 	stw	r20,16(sp)
   81024:	dcc00315 	stw	r19,12(sp)
   81028:	dc800215 	stw	r18,8(sp)
   8102c:	dc400115 	stw	r17,4(sp)
   81030:	dc000015 	stw	r16,0(sp)
   81034:	2021883a 	mov	r16,r4
   81038:	282d883a 	mov	r22,r5
   8103c:	3011883a 	mov	r8,r6
   81040:	382b883a 	mov	r21,r7
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   81044:	01800616 	blt	zero,r6,81060 <altera_avalon_jtag_uart_write+0x50>
   81048:	2829883a 	mov	r20,r5
   8104c:	00002106 	br	810d4 <altera_avalon_jtag_uart_write+0xc4>
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
    return ptr - start;
   81050:	a585c83a 	sub	r2,r20,r22
   81054:	00004306 	br	81164 <altera_avalon_jtag_uart_write+0x154>
  else if (flags & O_NONBLOCK)
   81058:	00bffd44 	movi	r2,-11
   8105c:	00004106 	br	81164 <altera_avalon_jtag_uart_write+0x154>
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   81060:	2829883a 	mov	r20,r5
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   81064:	84800c17 	ldw	r18,48(r16)
      out = sp->tx_out;
   81068:	81400d17 	ldw	r5,52(r16)

      if (in < out)
   8106c:	9140032e 	bgeu	r18,r5,8107c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   81070:	2c85c83a 	sub	r2,r5,r18
   81074:	11bfffc4 	addi	r6,r2,-1
   81078:	00000606 	br	81094 <altera_avalon_jtag_uart_write+0x84>
      else if (out > 0)
   8107c:	28000326 	beq	r5,zero,8108c <altera_avalon_jtag_uart_write+0x7c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   81080:	00820004 	movi	r2,2048
   81084:	148dc83a 	sub	r6,r2,r18
   81088:	00000206 	br	81094 <altera_avalon_jtag_uart_write+0x84>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   8108c:	0081ffc4 	movi	r2,2047
   81090:	148dc83a 	sub	r6,r2,r18

      if (n == 0)
   81094:	30002626 	beq	r6,zero,81130 <altera_avalon_jtag_uart_write+0x120>
        break;

      if (n > count)
   81098:	4027883a 	mov	r19,r8
   8109c:	3023883a 	mov	r17,r6
   810a0:	4180012e 	bgeu	r8,r6,810a8 <altera_avalon_jtag_uart_write+0x98>
   810a4:	4023883a 	mov	r17,r8
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
   810a8:	81020e04 	addi	r4,r16,2104
   810ac:	2489883a 	add	r4,r4,r18
   810b0:	a00b883a 	mov	r5,r20
   810b4:	880d883a 	mov	r6,r17
   810b8:	0081ffc0 	call	81ffc <memcpy>
      ptr   += n;
   810bc:	a469883a 	add	r20,r20,r17
      count -= n;
   810c0:	9c51c83a 	sub	r8,r19,r17

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   810c4:	9445883a 	add	r2,r18,r17
   810c8:	1081ffcc 	andi	r2,r2,2047
   810cc:	80800c15 	stw	r2,48(r16)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   810d0:	023fe416 	blt	zero,r8,81064 <altera_avalon_jtag_uart_write+0x54>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   810d4:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   810d8:	00bfff84 	movi	r2,-2
   810dc:	2084703a 	and	r2,r4,r2
   810e0:	1001703a 	wrctl	status,r2
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   810e4:	80800817 	ldw	r2,32(r16)
   810e8:	10800094 	ori	r2,r2,2
   810ec:	80800815 	stw	r2,32(r16)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   810f0:	80c00017 	ldw	r3,0(r16)
   810f4:	18800135 	stwio	r2,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   810f8:	2001703a 	wrctl	status,r4
   810fc:	00000706 	br	8111c <altera_avalon_jtag_uart_write+0x10c>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   81100:	80800d17 	ldw	r2,52(r16)
   81104:	1140031e 	bne	r2,r5,81114 <altera_avalon_jtag_uart_write+0x104>
   81108:	80c00917 	ldw	r3,36(r16)
   8110c:	80800117 	ldw	r2,4(r16)
   81110:	18bffb36 	bltu	r3,r2,81100 <altera_avalon_jtag_uart_write+0xf0>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
   81114:	80800d17 	ldw	r2,52(r16)
   81118:	117fed1e 	bne	r2,r5,810d0 <altera_avalon_jtag_uart_write+0xc0>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   8111c:	b53fcc1e 	bne	r22,r20,81050 <altera_avalon_jtag_uart_write+0x40>
    return ptr - start;
  else if (flags & O_NONBLOCK)
   81120:	a890000c 	andi	r2,r21,16384
   81124:	103fcc1e 	bne	r2,zero,81058 <altera_avalon_jtag_uart_write+0x48>
   81128:	00bffec4 	movi	r2,-5
   8112c:	00000d06 	br	81164 <altera_avalon_jtag_uart_write+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   81130:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   81134:	00bfff84 	movi	r2,-2
   81138:	2084703a 	and	r2,r4,r2
   8113c:	1001703a 	wrctl	status,r2
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   81140:	80800817 	ldw	r2,32(r16)
   81144:	10800094 	ori	r2,r2,2
   81148:	80800815 	stw	r2,32(r16)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   8114c:	80c00017 	ldw	r3,0(r16)
   81150:	18800135 	stwio	r2,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   81154:	2001703a 	wrctl	status,r4
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
   81158:	a890000c 	andi	r2,r21,16384
   8115c:	103fe826 	beq	r2,zero,81100 <altera_avalon_jtag_uart_write+0xf0>
   81160:	003fee06 	br	8111c <altera_avalon_jtag_uart_write+0x10c>
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
}
   81164:	dfc00717 	ldw	ra,28(sp)
   81168:	dd800617 	ldw	r22,24(sp)
   8116c:	dd400517 	ldw	r21,20(sp)
   81170:	dd000417 	ldw	r20,16(sp)
   81174:	dcc00317 	ldw	r19,12(sp)
   81178:	dc800217 	ldw	r18,8(sp)
   8117c:	dc400117 	ldw	r17,4(sp)
   81180:	dc000017 	ldw	r16,0(sp)
   81184:	dec00804 	addi	sp,sp,32
   81188:	f800283a 	ret

0008118c <epcs_read_device_id>:

  return res;
}

alt_u32 epcs_read_device_id(alt_u32 base)
{
   8118c:	defffb04 	addi	sp,sp,-20
   81190:	dfc00415 	stw	ra,16(sp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
   81194:	00bfe7c4 	movi	r2,-97
   81198:	d8800305 	stb	r2,12(sp)
  alt_u8 id[3];

  alt_avalon_spi_command(
   8119c:	01800044 	movi	r6,1
   811a0:	008000c4 	movi	r2,3
   811a4:	d8800015 	stw	r2,0(sp)
   811a8:	d8c00304 	addi	r3,sp,12
   811ac:	1985883a 	add	r2,r3,r6
   811b0:	d8800115 	stw	r2,4(sp)
   811b4:	d8000215 	stw	zero,8(sp)
   811b8:	000b883a 	mov	r5,zero
   811bc:	180f883a 	mov	r7,r3
   811c0:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
   811c4:	d9000383 	ldbu	r4,14(sp)
   811c8:	2008923a 	slli	r4,r4,8
   811cc:	d8800343 	ldbu	r2,13(sp)
   811d0:	1004943a 	slli	r2,r2,16
   811d4:	d8c003c3 	ldbu	r3,15(sp)
   811d8:	10c4b03a 	or	r2,r2,r3
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
}
   811dc:	2084b03a 	or	r2,r4,r2
   811e0:	dfc00417 	ldw	ra,16(sp)
   811e4:	dec00504 	addi	sp,sp,20
   811e8:	f800283a 	ret

000811ec <epcs_read_electronic_signature>:
  return length;
}


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
   811ec:	defffa04 	addi	sp,sp,-24
   811f0:	dfc00515 	stw	ra,20(sp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
   811f4:	00bfeac4 	movi	r2,-85
   811f8:	d8800305 	stb	r2,12(sp)
   811fc:	d8000345 	stb	zero,13(sp)
   81200:	d8000385 	stb	zero,14(sp)
   81204:	d80003c5 	stb	zero,15(sp)
  alt_u8 res;

  alt_avalon_spi_command(
   81208:	01800104 	movi	r6,4
   8120c:	00800044 	movi	r2,1
   81210:	d8800015 	stw	r2,0(sp)
   81214:	d8c00304 	addi	r3,sp,12
   81218:	1985883a 	add	r2,r3,r6
   8121c:	d8800115 	stw	r2,4(sp)
   81220:	d8000215 	stw	zero,8(sp)
   81224:	000b883a 	mov	r5,zero
   81228:	180f883a 	mov	r7,r3
   8122c:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
    &res,
    0
  );

  return res;
}
   81230:	d8800403 	ldbu	r2,16(sp)
   81234:	dfc00517 	ldw	ra,20(sp)
   81238:	dec00604 	addi	sp,sp,24
   8123c:	f800283a 	ret

00081240 <epcs_write_enable>:

  return length;
}

void epcs_write_enable(alt_u32 base)
{
   81240:	defffb04 	addi	sp,sp,-20
   81244:	dfc00415 	stw	ra,16(sp)
  const alt_u8 wren = epcs_wren;
   81248:	00800184 	movi	r2,6
   8124c:	d8800305 	stb	r2,12(sp)
  alt_avalon_spi_command(
   81250:	d8000015 	stw	zero,0(sp)
   81254:	d8000115 	stw	zero,4(sp)
   81258:	d8000215 	stw	zero,8(sp)
   8125c:	000b883a 	mov	r5,zero
   81260:	01800044 	movi	r6,1
   81264:	d9c00304 	addi	r7,sp,12
   81268:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
   8126c:	dfc00417 	ldw	ra,16(sp)
   81270:	dec00504 	addi	sp,sp,20
   81274:	f800283a 	ret

00081278 <epcs_exit_4_bytes_mode>:

  return;
}

void epcs_exit_4_bytes_mode(alt_u32 base)
{
   81278:	defffa04 	addi	sp,sp,-24
   8127c:	dfc00515 	stw	ra,20(sp)
   81280:	dc000415 	stw	r16,16(sp)
   81284:	2021883a 	mov	r16,r4
  const alt_u8 exit4b_cmd = epcs_dis4b;
   81288:	00bffa44 	movi	r2,-23
   8128c:	d8800305 	stb	r2,12(sp)

  /* First, WREN */
  epcs_write_enable(base);
   81290:	00812400 	call	81240 <epcs_write_enable>

  alt_avalon_spi_command(
   81294:	d8000015 	stw	zero,0(sp)
   81298:	d8000115 	stw	zero,4(sp)
   8129c:	d8000215 	stw	zero,8(sp)
   812a0:	8009883a 	mov	r4,r16
   812a4:	000b883a 	mov	r5,zero
   812a8:	01800044 	movi	r6,1
   812ac:	d9c00304 	addi	r7,sp,12
   812b0:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
   812b4:	dfc00517 	ldw	ra,20(sp)
   812b8:	dc000417 	ldw	r16,16(sp)
   812bc:	dec00604 	addi	sp,sp,24
   812c0:	f800283a 	ret

000812c4 <epcs_enter_4_bytes_mode>:

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
}

void epcs_enter_4_bytes_mode(alt_u32 base)
{
   812c4:	defffa04 	addi	sp,sp,-24
   812c8:	dfc00515 	stw	ra,20(sp)
   812cc:	dc000415 	stw	r16,16(sp)
   812d0:	2021883a 	mov	r16,r4
  const alt_u8 en4b_cmd = epcs_en4b;
   812d4:	00bfedc4 	movi	r2,-73
   812d8:	d8800305 	stb	r2,12(sp)

  /* First, WREN */
  epcs_write_enable(base);
   812dc:	00812400 	call	81240 <epcs_write_enable>

  alt_avalon_spi_command(
   812e0:	d8000015 	stw	zero,0(sp)
   812e4:	d8000115 	stw	zero,4(sp)
   812e8:	d8000215 	stw	zero,8(sp)
   812ec:	8009883a 	mov	r4,r16
   812f0:	000b883a 	mov	r5,zero
   812f4:	01800044 	movi	r6,1
   812f8:	d9c00304 	addi	r7,sp,12
   812fc:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
   81300:	dfc00517 	ldw	ra,20(sp)
   81304:	dc000417 	ldw	r16,16(sp)
   81308:	dec00604 	addi	sp,sp,24
   8130c:	f800283a 	ret

00081310 <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
   81310:	defffb04 	addi	sp,sp,-20
   81314:	dfc00415 	stw	ra,16(sp)
  const alt_u8 rdsr = epcs_rdsr;
   81318:	00800144 	movi	r2,5
   8131c:	d8800305 	stb	r2,12(sp)
  alt_u8 status;
  alt_avalon_spi_command(
   81320:	01800044 	movi	r6,1
   81324:	d9800015 	stw	r6,0(sp)
   81328:	d8c00304 	addi	r3,sp,12
   8132c:	1985883a 	add	r2,r3,r6
   81330:	d8800115 	stw	r2,4(sp)
   81334:	d8000215 	stw	zero,8(sp)
   81338:	000b883a 	mov	r5,zero
   8133c:	180f883a 	mov	r7,r3
   81340:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
    &status,
    0
  );

  return status;
}
   81344:	d8800343 	ldbu	r2,13(sp)
   81348:	dfc00417 	ldw	ra,16(sp)
   8134c:	dec00504 	addi	sp,sp,20
   81350:	f800283a 	ret

00081354 <epcs_sector_erase>:
  {
  }
}

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
   81354:	defff704 	addi	sp,sp,-36
   81358:	dfc00815 	stw	ra,32(sp)
   8135c:	dc800715 	stw	r18,28(sp)
   81360:	dc400615 	stw	r17,24(sp)
   81364:	dc000515 	stw	r16,20(sp)
   81368:	2021883a 	mov	r16,r4
   8136c:	3025883a 	mov	r18,r6
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
   81370:	30000c26 	beq	r6,zero,813a4 <epcs_sector_erase+0x50>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
   81374:	00bff604 	movi	r2,-40
   81378:	d8800305 	stb	r2,12(sp)
      se[1] = (offset >> 24) & 0xFF;
   8137c:	2804d63a 	srli	r2,r5,24
   81380:	d8800345 	stb	r2,13(sp)
      se[2] = (offset >> 16) & 0xFF;
   81384:	2804d43a 	srli	r2,r5,16
   81388:	d8800385 	stb	r2,14(sp)
      se[3] = (offset >> 8) & 0xFF;
   8138c:	2804d23a 	srli	r2,r5,8
   81390:	d88003c5 	stb	r2,15(sp)
      se[4] = offset & 0xFF;
   81394:	d9400405 	stb	r5,16(sp)
      len   = 5;
      epcs_enter_4_bytes_mode(base);
   81398:	00812c40 	call	812c4 <epcs_enter_4_bytes_mode>
   8139c:	04400144 	movi	r17,5
   813a0:	00000806 	br	813c4 <epcs_sector_erase+0x70>
  }
  else
  {
      se[0] = epcs_se;
   813a4:	00bff604 	movi	r2,-40
   813a8:	d8800305 	stb	r2,12(sp)
      se[1] = (offset >> 16) & 0xFF;
   813ac:	2804d43a 	srli	r2,r5,16
   813b0:	d8800345 	stb	r2,13(sp)
      se[2] = (offset >> 8) & 0xFF;
   813b4:	2804d23a 	srli	r2,r5,8
   813b8:	d8800385 	stb	r2,14(sp)
      se[3] = offset & 0xFF;
   813bc:	d94003c5 	stb	r5,15(sp)
   813c0:	04400104 	movi	r17,4
      len   = 4;
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
   813c4:	8009883a 	mov	r4,r16
   813c8:	00812400 	call	81240 <epcs_write_enable>

  alt_avalon_spi_command(
   813cc:	89803fcc 	andi	r6,r17,255
   813d0:	d8000015 	stw	zero,0(sp)
   813d4:	d8000115 	stw	zero,4(sp)
   813d8:	d8000215 	stw	zero,8(sp)
   813dc:	8009883a 	mov	r4,r16
   813e0:	000b883a 	mov	r5,zero
   813e4:	d9c00304 	addi	r7,sp,12
   813e8:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
  return status;
}

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
  return epcs_read_status_register(base) & 1;
   813ec:	8009883a 	mov	r4,r16
   813f0:	00813100 	call	81310 <epcs_read_status_register>
}

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
   813f4:	1080004c 	andi	r2,r2,1
   813f8:	103ffc1e 	bne	r2,zero,813ec <epcs_sector_erase+0x98>
    0
  );

  epcs_await_wip_released(base);

  if(four_bytes_mode)
   813fc:	90000226 	beq	r18,zero,81408 <epcs_sector_erase+0xb4>
  {
    epcs_exit_4_bytes_mode(base);
   81400:	8009883a 	mov	r4,r16
   81404:	00812780 	call	81278 <epcs_exit_4_bytes_mode>
  }
}
   81408:	dfc00817 	ldw	ra,32(sp)
   8140c:	dc800717 	ldw	r18,28(sp)
   81410:	dc400617 	ldw	r17,24(sp)
   81414:	dc000517 	ldw	r16,20(sp)
   81418:	dec00904 	addi	sp,sp,36
   8141c:	f800283a 	ret

00081420 <epcs_write_buffer>:
}

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
   81420:	defff504 	addi	sp,sp,-44
   81424:	dfc00a15 	stw	ra,40(sp)
   81428:	dd000915 	stw	r20,36(sp)
   8142c:	dcc00815 	stw	r19,32(sp)
   81430:	dc800715 	stw	r18,28(sp)
   81434:	dc400615 	stw	r17,24(sp)
   81438:	dc000515 	stw	r16,20(sp)
   8143c:	2021883a 	mov	r16,r4
   81440:	3027883a 	mov	r19,r6
   81444:	3825883a 	mov	r18,r7
   81448:	dd000b17 	ldw	r20,44(sp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
   8144c:	00800084 	movi	r2,2
   81450:	d8800305 	stb	r2,12(sp)
  
  if(four_bytes_mode)
   81454:	a0000a26 	beq	r20,zero,81480 <epcs_write_buffer+0x60>
  {
      pp[1] = (offset >> 24) & 0xFF;
   81458:	2805d63a 	srai	r2,r5,24
   8145c:	d8800345 	stb	r2,13(sp)
      pp[2] = (offset >> 16) & 0xFF;
   81460:	2805d43a 	srai	r2,r5,16
   81464:	d8800385 	stb	r2,14(sp)
      pp[3] = (offset >> 8) & 0xFF;
   81468:	2805d23a 	srai	r2,r5,8
   8146c:	d88003c5 	stb	r2,15(sp)
      pp[4] = offset & 0xFF;
   81470:	d9400405 	stb	r5,16(sp)
      cmd_len = 5;
      epcs_enter_4_bytes_mode(base);
   81474:	00812c40 	call	812c4 <epcs_enter_4_bytes_mode>
   81478:	04400144 	movi	r17,5
   8147c:	00000606 	br	81498 <epcs_write_buffer+0x78>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
   81480:	2805d43a 	srai	r2,r5,16
   81484:	d8800345 	stb	r2,13(sp)
      pp[2] = (offset >> 8) & 0xFF;
   81488:	2805d23a 	srai	r2,r5,8
   8148c:	d8800385 	stb	r2,14(sp)
      pp[3] = offset & 0xFF;
   81490:	d94003c5 	stb	r5,15(sp)
   81494:	04400104 	movi	r17,4
      cmd_len = 4;
  }

  /* First, WREN */
  epcs_write_enable(base);
   81498:	8009883a 	mov	r4,r16
   8149c:	00812400 	call	81240 <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
   814a0:	d8000015 	stw	zero,0(sp)
   814a4:	d8000115 	stw	zero,4(sp)
   814a8:	00800044 	movi	r2,1
   814ac:	d8800215 	stw	r2,8(sp)
   814b0:	8009883a 	mov	r4,r16
   814b4:	000b883a 	mov	r5,zero
   814b8:	880d883a 	mov	r6,r17
   814bc:	d9c00304 	addi	r7,sp,12
   814c0:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
   814c4:	d8000015 	stw	zero,0(sp)
   814c8:	d8000115 	stw	zero,4(sp)
   814cc:	d8000215 	stw	zero,8(sp)
   814d0:	8009883a 	mov	r4,r16
   814d4:	000b883a 	mov	r5,zero
   814d8:	900d883a 	mov	r6,r18
   814dc:	980f883a 	mov	r7,r19
   814e0:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
  return status;
}

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
  return epcs_read_status_register(base) & 1;
   814e4:	8009883a 	mov	r4,r16
   814e8:	00813100 	call	81310 <epcs_read_status_register>
}

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
   814ec:	1080004c 	andi	r2,r2,1
   814f0:	103ffc1e 	bne	r2,zero,814e4 <epcs_write_buffer+0xc4>
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);

  if(four_bytes_mode)
   814f4:	a0000226 	beq	r20,zero,81500 <epcs_write_buffer+0xe0>
  {
    epcs_exit_4_bytes_mode(base);
   814f8:	8009883a 	mov	r4,r16
   814fc:	00812780 	call	81278 <epcs_exit_4_bytes_mode>
  }

  return length;
}
   81500:	9005883a 	mov	r2,r18
   81504:	dfc00a17 	ldw	ra,40(sp)
   81508:	dd000917 	ldw	r20,36(sp)
   8150c:	dcc00817 	ldw	r19,32(sp)
   81510:	dc800717 	ldw	r18,28(sp)
   81514:	dc400617 	ldw	r17,24(sp)
   81518:	dc000517 	ldw	r16,20(sp)
   8151c:	dec00b04 	addi	sp,sp,44
   81520:	f800283a 	ret

00081524 <epcs_read_buffer>:
  }
}

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
   81524:	defff504 	addi	sp,sp,-44
   81528:	dfc00a15 	stw	ra,40(sp)
   8152c:	dd000915 	stw	r20,36(sp)
   81530:	dcc00815 	stw	r19,32(sp)
   81534:	dc800715 	stw	r18,28(sp)
   81538:	dc400615 	stw	r17,24(sp)
   8153c:	dc000515 	stw	r16,20(sp)
   81540:	2021883a 	mov	r16,r4
   81544:	3027883a 	mov	r19,r6
   81548:	3823883a 	mov	r17,r7
   8154c:	dd000b17 	ldw	r20,44(sp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
   81550:	008000c4 	movi	r2,3
   81554:	d8800305 	stb	r2,12(sp)
  
  if(four_bytes_mode)
   81558:	a0000a26 	beq	r20,zero,81584 <epcs_read_buffer+0x60>
  {
        read_command[1] = (offset >> 24) & 0xFF;
   8155c:	2805d63a 	srai	r2,r5,24
   81560:	d8800345 	stb	r2,13(sp)
        read_command[2] = (offset >> 16) & 0xFF;
   81564:	2805d43a 	srai	r2,r5,16
   81568:	d8800385 	stb	r2,14(sp)
        read_command[3] = (offset >> 8) & 0xFF;
   8156c:	2805d23a 	srai	r2,r5,8
   81570:	d88003c5 	stb	r2,15(sp)
        read_command[4] = offset & 0xFF;
   81574:	d9400405 	stb	r5,16(sp)
        cmd_len = 5;
        epcs_enter_4_bytes_mode(base);
   81578:	00812c40 	call	812c4 <epcs_enter_4_bytes_mode>
   8157c:	04800144 	movi	r18,5
   81580:	00000606 	br	8159c <epcs_read_buffer+0x78>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
   81584:	2805d43a 	srai	r2,r5,16
   81588:	d8800345 	stb	r2,13(sp)
        read_command[2] = (offset >> 8) & 0xFF;
   8158c:	2805d23a 	srai	r2,r5,8
   81590:	d8800385 	stb	r2,14(sp)
        read_command[3] = offset & 0xFF;
   81594:	d94003c5 	stb	r5,15(sp)
   81598:	04800104 	movi	r18,4
  return status;
}

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
  return epcs_read_status_register(base) & 1;
   8159c:	8009883a 	mov	r4,r16
   815a0:	00813100 	call	81310 <epcs_read_status_register>
}

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
   815a4:	1080004c 	andi	r2,r2,1
   815a8:	103ffc1e 	bne	r2,zero,8159c <epcs_read_buffer+0x78>
        cmd_len = 4;
  }

  epcs_await_wip_released(base);

  alt_avalon_spi_command(
   815ac:	dc400015 	stw	r17,0(sp)
   815b0:	dcc00115 	stw	r19,4(sp)
   815b4:	d8000215 	stw	zero,8(sp)
   815b8:	8009883a 	mov	r4,r16
   815bc:	000b883a 	mov	r5,zero
   815c0:	900d883a 	mov	r6,r18
   815c4:	d9c00304 	addi	r7,sp,12
   815c8:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
   815cc:	a0000226 	beq	r20,zero,815d8 <epcs_read_buffer+0xb4>
  {
    epcs_exit_4_bytes_mode(base);
   815d0:	8009883a 	mov	r4,r16
   815d4:	00812780 	call	81278 <epcs_exit_4_bytes_mode>
  }

  return length;
}
   815d8:	8805883a 	mov	r2,r17
   815dc:	dfc00a17 	ldw	ra,40(sp)
   815e0:	dd000917 	ldw	r20,36(sp)
   815e4:	dcc00817 	ldw	r19,32(sp)
   815e8:	dc800717 	ldw	r18,28(sp)
   815ec:	dc400617 	ldw	r17,24(sp)
   815f0:	dc000517 	ldw	r16,20(sp)
   815f4:	dec00b04 	addi	sp,sp,44
   815f8:	f800283a 	ret

000815fc <epcs_write_status_register>:
    0
  );
}

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
   815fc:	defffa04 	addi	sp,sp,-24
   81600:	dfc00515 	stw	ra,20(sp)
   81604:	dc000415 	stw	r16,16(sp)
   81608:	2021883a 	mov	r16,r4
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
   8160c:	00800044 	movi	r2,1
   81610:	d8800305 	stb	r2,12(sp)
  wrsr[1] = value;
   81614:	d9400345 	stb	r5,13(sp)

  alt_avalon_spi_command(
   81618:	d8000015 	stw	zero,0(sp)
   8161c:	d8000115 	stw	zero,4(sp)
   81620:	d8000215 	stw	zero,8(sp)
   81624:	000b883a 	mov	r5,zero
   81628:	01800084 	movi	r6,2
   8162c:	d9c00304 	addi	r7,sp,12
   81630:	0081cc80 	call	81cc8 <alt_avalon_spi_command>
  return status;
}

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
  return epcs_read_status_register(base) & 1;
   81634:	8009883a 	mov	r4,r16
   81638:	00813100 	call	81310 <epcs_read_status_register>
}

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
   8163c:	1080004c 	andi	r2,r2,1
   81640:	103ffc1e 	bne	r2,zero,81634 <epcs_write_status_register+0x38>
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
}
   81644:	dfc00517 	ldw	ra,20(sp)
   81648:	dc000417 	ldw	r16,16(sp)
   8164c:	dec00604 	addi	sp,sp,24
   81650:	f800283a 	ret

00081654 <alt_alarm_start>:
                     void* context)
{
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  
  if (alt_ticks_per_second ())
   81654:	00800234 	movhi	r2,8
   81658:	108d2604 	addi	r2,r2,13464
   8165c:	10800017 	ldw	r2,0(r2)
   81660:	1000021e 	bne	r2,zero,8166c <alt_alarm_start+0x18>
   81664:	00bfde84 	movi	r2,-134
   81668:	f800283a 	ret
  {
    if (alarm)
   8166c:	2000021e 	bne	r4,zero,81678 <alt_alarm_start+0x24>
   81670:	00bffa84 	movi	r2,-22
   81674:	f800283a 	ret
    {
      alarm->callback = callback;
   81678:	21800315 	stw	r6,12(r4)
      alarm->context  = context;
   8167c:	21c00515 	stw	r7,20(r4)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   81680:	000f303a 	rdctl	r7,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   81684:	00bfff84 	movi	r2,-2
   81688:	3884703a 	and	r2,r7,r2
   8168c:	1001703a 	wrctl	status,r2
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   81690:	00800234 	movhi	r2,8
   81694:	108d2704 	addi	r2,r2,13468
   81698:	10c00017 	ldw	r3,0(r2)
 
      irq_context = alt_irq_disable_all ();
      
      current_nticks = alt_nticks();
      
      alarm->time = nticks + current_nticks + 1; 
   8169c:	01800044 	movi	r6,1
   816a0:	1985883a 	add	r2,r3,r6
   816a4:	2885883a 	add	r2,r5,r2
   816a8:	20800215 	stw	r2,8(r4)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   816ac:	10c0022e 	bgeu	r2,r3,816b8 <alt_alarm_start+0x64>
      {
        alarm->rollover = 1;
   816b0:	21800405 	stb	r6,16(r4)
   816b4:	00000106 	br	816bc <alt_alarm_start+0x68>
      }
      else
      {
        alarm->rollover = 0;
   816b8:	20000405 	stb	zero,16(r4)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   816bc:	00800234 	movhi	r2,8
   816c0:	108d1f04 	addi	r2,r2,13436
   816c4:	20800115 	stw	r2,4(r4)
  entry->next     = list->next;
   816c8:	10c00017 	ldw	r3,0(r2)
   816cc:	20c00015 	stw	r3,0(r4)

  list->next->previous = entry;
   816d0:	10c00017 	ldw	r3,0(r2)
   816d4:	19000115 	stw	r4,4(r3)
  list->next           = entry;
   816d8:	11000015 	stw	r4,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   816dc:	3801703a 	wrctl	status,r7
   816e0:	0005883a 	mov	r2,zero
  }
  else
  {
    return -ENOTSUP;
  }
}
   816e4:	f800283a 	ret

000816e8 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
   816e8:	3005883a 	mov	r2,r6
   816ec:	f800283a 	ret

000816f0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   816f0:	deffff04 	addi	sp,sp,-4
   816f4:	dfc00015 	stw	ra,0(sp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   816f8:	20000226 	beq	r4,zero,81704 <alt_dev_llist_insert+0x14>
   816fc:	20800217 	ldw	r2,8(r4)
   81700:	10000d1e 	bne	r2,zero,81738 <alt_dev_llist_insert+0x48>
   81704:	00800234 	movhi	r2,8
   81708:	108d1b04 	addi	r2,r2,13420
   8170c:	10800017 	ldw	r2,0(r2)
   81710:	1000031e 	bne	r2,zero,81720 <alt_dev_llist_insert+0x30>
   81714:	00c00234 	movhi	r3,8
   81718:	18cd2104 	addi	r3,r3,13444
   8171c:	00000206 	br	81728 <alt_dev_llist_insert+0x38>
   81720:	103ee83a 	callr	r2
   81724:	1007883a 	mov	r3,r2
  {
    ALT_ERRNO = EINVAL;
   81728:	00800584 	movi	r2,22
   8172c:	18800015 	stw	r2,0(r3)
   81730:	00bffa84 	movi	r2,-22
   81734:	00000706 	br	81754 <alt_dev_llist_insert+0x64>
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   81738:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
   8173c:	28800017 	ldw	r2,0(r5)
   81740:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
   81744:	28800017 	ldw	r2,0(r5)
   81748:	11000115 	stw	r4,4(r2)
  list->next           = entry;
   8174c:	29000015 	stw	r4,0(r5)
   81750:	0005883a 	mov	r2,zero
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
   81754:	dfc00017 	ldw	ra,0(sp)
   81758:	dec00104 	addi	sp,sp,4
   8175c:	f800283a 	ret

00081760 <alt_flash_close_dev>:

  return dev;
}

void alt_flash_close_dev(alt_flash_fd* fd)
{
   81760:	deffff04 	addi	sp,sp,-4
   81764:	dfc00015 	stw	ra,0(sp)
  if (fd && fd->close)
   81768:	20000326 	beq	r4,zero,81778 <alt_flash_close_dev+0x18>
   8176c:	20800417 	ldw	r2,16(r4)
   81770:	10000126 	beq	r2,zero,81778 <alt_flash_close_dev+0x18>
  {
    fd->close(fd);
   81774:	103ee83a 	callr	r2
  }
  return;
}
   81778:	dfc00017 	ldw	ra,0(sp)
   8177c:	dec00104 	addi	sp,sp,4
   81780:	f800283a 	ret

00081784 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   81784:	defffe04 	addi	sp,sp,-8
   81788:	dfc00115 	stw	ra,4(sp)
   8178c:	dc000015 	stw	r16,0(sp)
   81790:	2021883a 	mov	r16,r4
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   81794:	d1600804 	addi	r5,gp,-32736
   81798:	0081df40 	call	81df4 <alt_find_dev>

  if ((dev) && dev->open)
   8179c:	10000526 	beq	r2,zero,817b4 <alt_flash_open_dev+0x30>
   817a0:	10c00317 	ldw	r3,12(r2)
   817a4:	18000326 	beq	r3,zero,817b4 <alt_flash_open_dev+0x30>
  {
    return dev->open(dev, name);
   817a8:	1009883a 	mov	r4,r2
   817ac:	800b883a 	mov	r5,r16
   817b0:	183ee83a 	callr	r3
  }

  return dev;
}
   817b4:	dfc00117 	ldw	ra,4(sp)
   817b8:	dc000017 	ldw	r16,0(sp)
   817bc:	dec00204 	addi	sp,sp,8
   817c0:	f800283a 	ret

000817c4 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   817c4:	000530fa 	rdctl	r2,ienable
   817c8:	00c00044 	movi	r3,1
   817cc:	1946983a 	sll	r3,r3,r5
   817d0:	10c4703a 	and	r2,r2,r3

    return (irq_enabled & (1 << irq)) ? 1: 0;
}
   817d4:	1004c03a 	cmpne	r2,r2,zero
   817d8:	f800283a 	ret

000817dc <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   817dc:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   817e0:	00bfff84 	movi	r2,-2
   817e4:	3084703a 	and	r2,r6,r2
   817e8:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
   817ec:	00c00234 	movhi	r3,8
   817f0:	18cd2504 	addi	r3,r3,13460
   817f4:	19000017 	ldw	r4,0(r3)
   817f8:	00800044 	movi	r2,1
   817fc:	1144983a 	sll	r2,r2,r5
   81800:	1104b03a 	or	r2,r2,r4
   81804:	18800015 	stw	r2,0(r3)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   81808:	18800017 	ldw	r2,0(r3)
   8180c:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   81810:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
   81814:	0005883a 	mov	r2,zero
   81818:	f800283a 	ret

0008181c <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   8181c:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   81820:	00bfff84 	movi	r2,-2
   81824:	3084703a 	and	r2,r6,r2
   81828:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
   8182c:	00c00234 	movhi	r3,8
   81830:	18cd2504 	addi	r3,r3,13460
   81834:	19000017 	ldw	r4,0(r3)
   81838:	00bfff84 	movi	r2,-2
   8183c:	1144183a 	rol	r2,r2,r5
   81840:	1104703a 	and	r2,r2,r4
   81844:	18800015 	stw	r2,0(r3)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   81848:	18800017 	ldw	r2,0(r3)
   8184c:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   81850:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
   81854:	0005883a 	mov	r2,zero
   81858:	f800283a 	ret

0008185c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   8185c:	defffe04 	addi	sp,sp,-8
   81860:	dfc00115 	stw	ra,4(sp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   81864:	d8800217 	ldw	r2,8(sp)
   81868:	d8800015 	stw	r2,0(sp)
   8186c:	008187c0 	call	8187c <alt_iic_isr_register>
}  
   81870:	dfc00117 	ldw	ra,4(sp)
   81874:	dec00204 	addi	sp,sp,8
   81878:	f800283a 	ret

0008187c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   8187c:	defffe04 	addi	sp,sp,-8
   81880:	dfc00115 	stw	ra,4(sp)
   81884:	dc000015 	stw	r16,0(sp)
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
   81888:	008007c4 	movi	r2,31
   8188c:	1140020e 	bge	r2,r5,81898 <alt_iic_isr_register+0x1c>
   81890:	00bffa84 	movi	r2,-22
   81894:	00000f06 	br	818d4 <alt_iic_isr_register+0x58>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   81898:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   8189c:	00bfff84 	movi	r2,-2
   818a0:	8084703a 	and	r2,r16,r2
   818a4:	1001703a 	wrctl	status,r2
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
   818a8:	280490fa 	slli	r2,r5,3
   818ac:	00c00234 	movhi	r3,8
   818b0:	18cd2804 	addi	r3,r3,13472
   818b4:	10c5883a 	add	r2,r2,r3
   818b8:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
   818bc:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   818c0:	30000226 	beq	r6,zero,818cc <alt_iic_isr_register+0x50>
   818c4:	00817dc0 	call	817dc <alt_ic_irq_enable>
   818c8:	00000106 	br	818d0 <alt_iic_isr_register+0x54>
   818cc:	008181c0 	call	8181c <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   818d0:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
   818d4:	dfc00117 	ldw	ra,4(sp)
   818d8:	dc000017 	ldw	r16,0(sp)
   818dc:	dec00204 	addi	sp,sp,8
   818e0:	f800283a 	ret

000818e4 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   818e4:	defffd04 	addi	sp,sp,-12
   818e8:	dfc00215 	stw	ra,8(sp)
   818ec:	dc400115 	stw	r17,4(sp)
   818f0:	dc000015 	stw	r16,0(sp)
   818f4:	2023883a 	mov	r17,r4
  int old;

  old = open (name, flags, mode);
   818f8:	2809883a 	mov	r4,r5
   818fc:	300b883a 	mov	r5,r6
   81900:	380d883a 	mov	r6,r7
   81904:	00819f40 	call	819f4 <open>
   81908:	1021883a 	mov	r16,r2

  if (old >= 0)
   8190c:	10000e16 	blt	r2,zero,81948 <alt_open_fd+0x64>
  {
    fd->dev      = alt_fd_list[old].dev;
   81910:	1009883a 	mov	r4,r2
   81914:	01400304 	movi	r5,12
   81918:	00820280 	call	82028 <__mulsi3>
   8191c:	00c00234 	movhi	r3,8
   81920:	18ccb404 	addi	r3,r3,13008
   81924:	10c5883a 	add	r2,r2,r3
   81928:	10c00017 	ldw	r3,0(r2)
   8192c:	88c00015 	stw	r3,0(r17)
    fd->priv     = alt_fd_list[old].priv;
   81930:	10c00117 	ldw	r3,4(r2)
   81934:	88c00115 	stw	r3,4(r17)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   81938:	10800217 	ldw	r2,8(r2)
   8193c:	88800215 	stw	r2,8(r17)

    alt_release_fd (old);
   81940:	8009883a 	mov	r4,r16
   81944:	0081b780 	call	81b78 <alt_release_fd>
  }
} 
   81948:	dfc00217 	ldw	ra,8(sp)
   8194c:	dc400117 	ldw	r17,4(sp)
   81950:	dc000017 	ldw	r16,0(sp)
   81954:	dec00304 	addi	sp,sp,12
   81958:	f800283a 	ret

0008195c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   8195c:	defffa04 	addi	sp,sp,-24
   81960:	dfc00515 	stw	ra,20(sp)
   81964:	dd000415 	stw	r20,16(sp)
   81968:	dcc00315 	stw	r19,12(sp)
   8196c:	dc800215 	stw	r18,8(sp)
   81970:	dc400115 	stw	r17,4(sp)
   81974:	dc000015 	stw	r16,0(sp)
   81978:	2005883a 	mov	r2,r4
   8197c:	2827883a 	mov	r19,r5
   81980:	3029883a 	mov	r20,r6
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   81984:	04000234 	movhi	r16,8
   81988:	840cb704 	addi	r16,r16,13020
   8198c:	04800044 	movi	r18,1
   81990:	04407fc4 	movi	r17,511
   81994:	8009883a 	mov	r4,r16
   81998:	100b883a 	mov	r5,r2
   8199c:	900d883a 	mov	r6,r18
   819a0:	880f883a 	mov	r7,r17
   819a4:	00818e40 	call	818e4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   819a8:	843ffd04 	addi	r16,r16,-12
   819ac:	8009883a 	mov	r4,r16
   819b0:	980b883a 	mov	r5,r19
   819b4:	000d883a 	mov	r6,zero
   819b8:	880f883a 	mov	r7,r17
   819bc:	00818e40 	call	818e4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   819c0:	81000604 	addi	r4,r16,24
   819c4:	a00b883a 	mov	r5,r20
   819c8:	900d883a 	mov	r6,r18
   819cc:	880f883a 	mov	r7,r17
   819d0:	00818e40 	call	818e4 <alt_open_fd>
}  
   819d4:	dfc00517 	ldw	ra,20(sp)
   819d8:	dd000417 	ldw	r20,16(sp)
   819dc:	dcc00317 	ldw	r19,12(sp)
   819e0:	dc800217 	ldw	r18,8(sp)
   819e4:	dc400117 	ldw	r17,4(sp)
   819e8:	dc000017 	ldw	r16,0(sp)
   819ec:	dec00604 	addi	sp,sp,24
   819f0:	f800283a 	ret

000819f4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   819f4:	defff904 	addi	sp,sp,-28
   819f8:	dfc00615 	stw	ra,24(sp)
   819fc:	dd400515 	stw	r21,20(sp)
   81a00:	dd000415 	stw	r20,16(sp)
   81a04:	dcc00315 	stw	r19,12(sp)
   81a08:	dc800215 	stw	r18,8(sp)
   81a0c:	dc400115 	stw	r17,4(sp)
   81a10:	dc000015 	stw	r16,0(sp)
   81a14:	2029883a 	mov	r20,r4
   81a18:	2827883a 	mov	r19,r5
   81a1c:	302b883a 	mov	r21,r6
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   81a20:	01400234 	movhi	r5,8
   81a24:	294d1804 	addi	r5,r5,13408
   81a28:	0081df40 	call	81df4 <alt_find_dev>
   81a2c:	1021883a 	mov	r16,r2
   81a30:	10000226 	beq	r2,zero,81a3c <open+0x48>
   81a34:	0025883a 	mov	r18,zero
   81a38:	00000a06 	br	81a64 <open+0x70>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   81a3c:	a009883a 	mov	r4,r20
   81a40:	0081e640 	call	81e64 <alt_find_file>
   81a44:	1021883a 	mov	r16,r2

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   81a48:	1000051e 	bne	r2,zero,81a60 <open+0x6c>
   81a4c:	047fffc4 	movi	r17,-1
   81a50:	043ffb44 	movi	r16,-19
   81a54:	00002d06 	br	81b0c <open+0x118>
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   81a58:	043ffcc4 	movi	r16,-13
   81a5c:	00002b06 	br	81b0c <open+0x118>

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   81a60:	04800044 	movi	r18,1
  {
    if ((index = alt_get_fd (dev)) < 0)
   81a64:	8009883a 	mov	r4,r16
   81a68:	0081f200 	call	81f20 <alt_get_fd>
   81a6c:	1023883a 	mov	r17,r2
   81a70:	10003516 	blt	r2,zero,81b48 <open+0x154>
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
   81a74:	1009883a 	mov	r4,r2
   81a78:	01400304 	movi	r5,12
   81a7c:	00820280 	call	82028 <__mulsi3>
   81a80:	02000234 	movhi	r8,8
   81a84:	420cb404 	addi	r8,r8,13008
   81a88:	1209883a 	add	r4,r2,r8
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   81a8c:	00900034 	movhi	r2,16384
   81a90:	10bfffc4 	addi	r2,r2,-1
   81a94:	9886703a 	and	r3,r19,r2
   81a98:	20c00215 	stw	r3,8(r4)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   81a9c:	9004c03a 	cmpne	r2,r18,zero
   81aa0:	1000121e 	bne	r2,zero,81aec <open+0xf8>

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   81aa4:	18900034 	orhi	r2,r3,16384
   81aa8:	20800215 	stw	r2,8(r4)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   81aac:	00800234 	movhi	r2,8
   81ab0:	108d1a04 	addi	r2,r2,13416
   81ab4:	11c00017 	ldw	r7,0(r2)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   81ab8:	21800017 	ldw	r6,0(r4)
   81abc:	000b883a 	mov	r5,zero
   81ac0:	4007883a 	mov	r3,r8
   81ac4:	02400044 	movi	r9,1
   81ac8:	02000304 	movi	r8,12
   81acc:	18800017 	ldw	r2,0(r3)
   81ad0:	1180031e 	bne	r2,r6,81ae0 <open+0xec>
   81ad4:	18800217 	ldw	r2,8(r3)
   81ad8:	1000010e 	bge	r2,zero,81ae0 <open+0xec>
   81adc:	193fde1e 	bne	r3,r4,81a58 <open+0x64>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   81ae0:	2a4b883a 	add	r5,r5,r9
   81ae4:	1a07883a 	add	r3,r3,r8
   81ae8:	397ff82e 	bgeu	r7,r5,81acc <open+0xd8>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   81aec:	80800317 	ldw	r2,12(r16)
   81af0:	10001726 	beq	r2,zero,81b50 <open+0x15c>
   81af4:	a00b883a 	mov	r5,r20
   81af8:	980d883a 	mov	r6,r19
   81afc:	a80f883a 	mov	r7,r21
   81b00:	103ee83a 	callr	r2
   81b04:	1021883a 	mov	r16,r2
    status = -ENODEV;
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   81b08:	1000110e 	bge	r2,zero,81b50 <open+0x15c>
  {
    alt_release_fd (index);  
   81b0c:	8809883a 	mov	r4,r17
   81b10:	0081b780 	call	81b78 <alt_release_fd>
   81b14:	00800234 	movhi	r2,8
   81b18:	108d1b04 	addi	r2,r2,13420
   81b1c:	10800017 	ldw	r2,0(r2)
   81b20:	1000031e 	bne	r2,zero,81b30 <open+0x13c>
   81b24:	00c00234 	movhi	r3,8
   81b28:	18cd2104 	addi	r3,r3,13444
   81b2c:	00000206 	br	81b38 <open+0x144>
   81b30:	103ee83a 	callr	r2
   81b34:	1007883a 	mov	r3,r2
    ALT_ERRNO = -status;
   81b38:	0405c83a 	sub	r2,zero,r16
   81b3c:	18800015 	stw	r2,0(r3)
   81b40:	047fffc4 	movi	r17,-1
   81b44:	00000206 	br	81b50 <open+0x15c>
   81b48:	1021883a 	mov	r16,r2
   81b4c:	003fef06 	br	81b0c <open+0x118>
  }
  
  /* return the reference upon success */

  return index;
}
   81b50:	8805883a 	mov	r2,r17
   81b54:	dfc00617 	ldw	ra,24(sp)
   81b58:	dd400517 	ldw	r21,20(sp)
   81b5c:	dd000417 	ldw	r20,16(sp)
   81b60:	dcc00317 	ldw	r19,12(sp)
   81b64:	dc800217 	ldw	r18,8(sp)
   81b68:	dc400117 	ldw	r17,4(sp)
   81b6c:	dc000017 	ldw	r16,0(sp)
   81b70:	dec00704 	addi	sp,sp,28
   81b74:	f800283a 	ret

00081b78 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   81b78:	defffc04 	addi	sp,sp,-16
   81b7c:	dfc00315 	stw	ra,12(sp)
   81b80:	dc800215 	stw	r18,8(sp)
   81b84:	dc400115 	stw	r17,4(sp)
   81b88:	dc000015 	stw	r16,0(sp)
   81b8c:	2025883a 	mov	r18,r4
  if (fd > 2)
   81b90:	00800084 	movi	r2,2
   81b94:	11000c0e 	bge	r2,r4,81bc8 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   81b98:	04400234 	movhi	r17,8
   81b9c:	8c4cb404 	addi	r17,r17,13008
   81ba0:	04000304 	movi	r16,12
   81ba4:	800b883a 	mov	r5,r16
   81ba8:	00820280 	call	82028 <__mulsi3>
   81bac:	1445883a 	add	r2,r2,r17
   81bb0:	10000215 	stw	zero,8(r2)
    alt_fd_list[fd].dev      = 0;
   81bb4:	9009883a 	mov	r4,r18
   81bb8:	800b883a 	mov	r5,r16
   81bbc:	00820280 	call	82028 <__mulsi3>
   81bc0:	1445883a 	add	r2,r2,r17
   81bc4:	10000015 	stw	zero,0(r2)
  }
}
   81bc8:	dfc00317 	ldw	ra,12(sp)
   81bcc:	dc800217 	ldw	r18,8(sp)
   81bd0:	dc400117 	ldw	r17,4(sp)
   81bd4:	dc000017 	ldw	r16,0(sp)
   81bd8:	dec00404 	addi	sp,sp,16
   81bdc:	f800283a 	ret

00081be0 <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   81be0:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   81be4:	00bfff84 	movi	r2,-2
   81be8:	2884703a 	and	r2,r5,r2
   81bec:	1001703a 	wrctl	status,r2
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   81bf0:	20c00017 	ldw	r3,0(r4)
   81bf4:	20800117 	ldw	r2,4(r4)
   81bf8:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
   81bfc:	20800117 	ldw	r2,4(r4)
   81c00:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   81c04:	21000115 	stw	r4,4(r4)
  entry->next     = entry;
   81c08:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   81c0c:	2801703a 	wrctl	status,r5
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  alt_llist_remove (&alarm->llist);
  alt_irq_enable_all (irq_context);
}
   81c10:	f800283a 	ret

00081c14 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   81c14:	defffd04 	addi	sp,sp,-12
   81c18:	dfc00215 	stw	ra,8(sp)
   81c1c:	dc400115 	stw	r17,4(sp)
   81c20:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   81c24:	d4200b17 	ldw	r16,-32724(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   81c28:	d0a01317 	ldw	r2,-32692(gp)
   81c2c:	10800044 	addi	r2,r2,1
   81c30:	d0a01315 	stw	r2,-32692(gp)
   81c34:	00001b06 	br	81ca4 <alt_tick+0x90>

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
   81c38:	84400017 	ldw	r17,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   81c3c:	80800403 	ldbu	r2,16(r16)
   81c40:	10000326 	beq	r2,zero,81c50 <alt_tick+0x3c>
   81c44:	d0a01317 	ldw	r2,-32692(gp)
   81c48:	1000011e 	bne	r2,zero,81c50 <alt_tick+0x3c>
    {
      alarm->rollover = 0;
   81c4c:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   81c50:	d0e01317 	ldw	r3,-32692(gp)
   81c54:	80800217 	ldw	r2,8(r16)
   81c58:	18801136 	bltu	r3,r2,81ca0 <alt_tick+0x8c>
   81c5c:	80800403 	ldbu	r2,16(r16)
   81c60:	10000f1e 	bne	r2,zero,81ca0 <alt_tick+0x8c>
    {
      next_callback = alarm->callback (alarm->context);
   81c64:	80800317 	ldw	r2,12(r16)
   81c68:	81000517 	ldw	r4,20(r16)
   81c6c:	103ee83a 	callr	r2
   81c70:	1007883a 	mov	r3,r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   81c74:	1000031e 	bne	r2,zero,81c84 <alt_tick+0x70>
      {
        alt_alarm_stop (alarm);
   81c78:	8009883a 	mov	r4,r16
   81c7c:	0081be00 	call	81be0 <alt_alarm_stop>
   81c80:	00000706 	br	81ca0 <alt_tick+0x8c>
      }
      else
      {
        alarm->time += next_callback;
   81c84:	80800217 	ldw	r2,8(r16)
   81c88:	1885883a 	add	r2,r3,r2
   81c8c:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   81c90:	d0e01317 	ldw	r3,-32692(gp)
   81c94:	10c0022e 	bgeu	r2,r3,81ca0 <alt_tick+0x8c>
        {
          alarm->rollover = 1;
   81c98:	00800044 	movi	r2,1
   81c9c:	80800405 	stb	r2,16(r16)
   81ca0:	8821883a 	mov	r16,r17

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   81ca4:	d0a00b04 	addi	r2,gp,-32724
   81ca8:	80bfe31e 	bne	r16,r2,81c38 <alt_tick+0x24>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
   81cac:	dfc00217 	ldw	ra,8(sp)
   81cb0:	dc400117 	ldw	r17,4(sp)
   81cb4:	dc000017 	ldw	r16,0(sp)
   81cb8:	dec00304 	addi	sp,sp,12
   81cbc:	f800283a 	ret

00081cc0 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   81cc0:	000170fa 	wrctl	ienable,zero
}
   81cc4:	f800283a 	ret

00081cc8 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
   81cc8:	defffb04 	addi	sp,sp,-20
   81ccc:	dd000415 	stw	r20,16(sp)
   81cd0:	dcc00315 	stw	r19,12(sp)
   81cd4:	dc800215 	stw	r18,8(sp)
   81cd8:	dc400115 	stw	r17,4(sp)
   81cdc:	dc000015 	stw	r16,0(sp)
   81ce0:	dcc00517 	ldw	r19,20(sp)
   81ce4:	da800617 	ldw	r10,24(sp)
   81ce8:	dd000717 	ldw	r20,28(sp)
  const alt_u8 * write_end = write_data + write_length;
   81cec:	31df883a 	add	r15,r6,r7
  alt_u8 * read_end = read_data + read_length;
   81cf0:	9aa3883a 	add	r17,r19,r10
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   81cf4:	2025883a 	mov	r18,r4
   81cf8:	00800044 	movi	r2,1
   81cfc:	1144983a 	sll	r2,r2,r5
   81d00:	20800535 	stwio	r2,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   81d04:	a080008c 	andi	r2,r20,2
   81d08:	1000021e 	bne	r2,zero,81d14 <alt_avalon_spi_command+0x4c>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   81d0c:	00810004 	movi	r2,1024
   81d10:	20800335 	stwio	r2,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   81d14:	20800037 	ldwio	r2,0(r4)
   81d18:	9817883a 	mov	r11,r19
   81d1c:	02000044 	movi	r8,1
   81d20:	92400204 	addi	r9,r18,8
   81d24:	03802004 	movi	r14,128
   81d28:	037fffc4 	movi	r13,-1
   81d2c:	4019883a 	mov	r12,r8
   81d30:	94000104 	addi	r16,r18,4
   81d34:	00000106 	br	81d3c <alt_avalon_spi_command+0x74>
   81d38:	000d883a 	mov	r6,zero
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   81d3c:	49400037 	ldwio	r5,0(r9)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
   81d40:	28c0100c 	andi	r3,r5,64
   81d44:	18000126 	beq	r3,zero,81d4c <alt_avalon_spi_command+0x84>
   81d48:	4000031e 	bne	r8,zero,81d58 <alt_avalon_spi_command+0x90>
   81d4c:	2b84703a 	and	r2,r5,r14
   81d50:	103ffa26 	beq	r2,zero,81d3c <alt_avalon_spi_command+0x74>

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   81d54:	18000e26 	beq	r3,zero,81d90 <alt_avalon_spi_command+0xc8>
   81d58:	02000b0e 	bge	zero,r8,81d88 <alt_avalon_spi_command+0xc0>
    {
      credits--;
   81d5c:	4351883a 	add	r8,r8,r13

      if (write_data < write_end)
   81d60:	3bc0042e 	bgeu	r7,r15,81d74 <alt_avalon_spi_command+0xac>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
   81d64:	38800003 	ldbu	r2,0(r7)
   81d68:	3b0f883a 	add	r7,r7,r12
   81d6c:	80800035 	stwio	r2,0(r16)
   81d70:	00000506 	br	81d88 <alt_avalon_spi_command+0xc0>
      else if (write_zeros > 0)
   81d74:	5800021e 	bne	r11,zero,81d80 <alt_avalon_spi_command+0xb8>
   81d78:	023f0004 	movi	r8,-1024
   81d7c:	00000206 	br	81d88 <alt_avalon_spi_command+0xc0>
      {
        write_zeros--;
   81d80:	5b57883a 	add	r11,r11,r13
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
   81d84:	80000035 	stwio	zero,0(r16)
      }
      else
        credits = -1024;
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   81d88:	2b84703a 	and	r2,r5,r14
   81d8c:	103feb26 	beq	r2,zero,81d3c <alt_avalon_spi_command+0x74>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   81d90:	20800037 	ldwio	r2,0(r4)

      if (read_ignore > 0)
   81d94:	30000426 	beq	r6,zero,81da8 <alt_avalon_spi_command+0xe0>
        read_ignore--;
   81d98:	334d883a 	add	r6,r6,r13
      else
        *read_data++ = (alt_u8)rxdata;
      credits++;
   81d9c:	4311883a 	add	r8,r8,r12

      if (read_ignore == 0 && read_data == read_end)
   81da0:	30000426 	beq	r6,zero,81db4 <alt_avalon_spi_command+0xec>
   81da4:	003fe506 	br	81d3c <alt_avalon_spi_command+0x74>
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);

      if (read_ignore > 0)
        read_ignore--;
      else
        *read_data++ = (alt_u8)rxdata;
   81da8:	50800005 	stb	r2,0(r10)
   81dac:	5315883a 	add	r10,r10,r12
      credits++;
   81db0:	4311883a 	add	r8,r8,r12

      if (read_ignore == 0 && read_data == read_end)
   81db4:	8abfe01e 	bne	r17,r10,81d38 <alt_avalon_spi_command+0x70>
   81db8:	00c00804 	movi	r3,32
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   81dbc:	48800037 	ldwio	r2,0(r9)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   81dc0:	10c4703a 	and	r2,r2,r3
   81dc4:	103ffd26 	beq	r2,zero,81dbc <alt_avalon_spi_command+0xf4>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   81dc8:	a080004c 	andi	r2,r20,1
   81dcc:	1000011e 	bne	r2,zero,81dd4 <alt_avalon_spi_command+0x10c>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   81dd0:	90000335 	stwio	zero,12(r18)

  return read_length;
}
   81dd4:	9805883a 	mov	r2,r19
   81dd8:	dd000417 	ldw	r20,16(sp)
   81ddc:	dcc00317 	ldw	r19,12(sp)
   81de0:	dc800217 	ldw	r18,8(sp)
   81de4:	dc400117 	ldw	r17,4(sp)
   81de8:	dc000017 	ldw	r16,0(sp)
   81dec:	dec00504 	addi	sp,sp,20
   81df0:	f800283a 	ret

00081df4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   81df4:	defffb04 	addi	sp,sp,-20
   81df8:	dfc00415 	stw	ra,16(sp)
   81dfc:	dcc00315 	stw	r19,12(sp)
   81e00:	dc800215 	stw	r18,8(sp)
   81e04:	dc400115 	stw	r17,4(sp)
   81e08:	dc000015 	stw	r16,0(sp)
   81e0c:	2027883a 	mov	r19,r4
   81e10:	2821883a 	mov	r16,r5
  alt_dev* next = (alt_dev*) llist->next;
   81e14:	2c400017 	ldw	r17,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
   81e18:	00802c40 	call	802c4 <strlen>
   81e1c:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   81e20:	8c000726 	beq	r17,r16,81e40 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   81e24:	89000217 	ldw	r4,8(r17)
   81e28:	980b883a 	mov	r5,r19
   81e2c:	900d883a 	mov	r6,r18
   81e30:	0081fc00 	call	81fc0 <memcmp>
   81e34:	10000326 	beq	r2,zero,81e44 <alt_find_dev+0x50>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
   81e38:	8c400017 	ldw	r17,0(r17)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   81e3c:	847ff91e 	bne	r16,r17,81e24 <alt_find_dev+0x30>
   81e40:	0023883a 	mov	r17,zero
  }
  
  /* No match found */
  
  return NULL;
}
   81e44:	8805883a 	mov	r2,r17
   81e48:	dfc00417 	ldw	ra,16(sp)
   81e4c:	dcc00317 	ldw	r19,12(sp)
   81e50:	dc800217 	ldw	r18,8(sp)
   81e54:	dc400117 	ldw	r17,4(sp)
   81e58:	dc000017 	ldw	r16,0(sp)
   81e5c:	dec00504 	addi	sp,sp,20
   81e60:	f800283a 	ret

00081e64 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   81e64:	defff904 	addi	sp,sp,-28
   81e68:	dfc00615 	stw	ra,24(sp)
   81e6c:	dd400515 	stw	r21,20(sp)
   81e70:	dd000415 	stw	r20,16(sp)
   81e74:	dcc00315 	stw	r19,12(sp)
   81e78:	dc800215 	stw	r18,8(sp)
   81e7c:	dc400115 	stw	r17,4(sp)
   81e80:	dc000015 	stw	r16,0(sp)
   81e84:	2025883a 	mov	r18,r4
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   81e88:	00800234 	movhi	r2,8
   81e8c:	108d1604 	addi	r2,r2,13400
   81e90:	14400017 	ldw	r17,0(r2)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   81e94:	102b883a 	mov	r21,r2
   81e98:	88801626 	beq	r17,r2,81ef4 <alt_find_file+0x90>
   81e9c:	053fffc4 	movi	r20,-1
   81ea0:	04c00bc4 	movi	r19,47
  {
    len = strlen(next->name);
   81ea4:	8c000217 	ldw	r16,8(r17)
   81ea8:	8009883a 	mov	r4,r16
   81eac:	00802c40 	call	802c4 <strlen>
   81eb0:	1007883a 	mov	r3,r2
    
    if (next->name[len-1] == '/')
   81eb4:	8085883a 	add	r2,r16,r2
   81eb8:	1505883a 	add	r2,r2,r20
   81ebc:	10800007 	ldb	r2,0(r2)
   81ec0:	14c0011e 	bne	r2,r19,81ec8 <alt_find_file+0x64>
    {
      len -= 1;
   81ec4:	1d07883a 	add	r3,r3,r20
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   81ec8:	1c85883a 	add	r2,r3,r18
   81ecc:	10800007 	ldb	r2,0(r2)
   81ed0:	14c00126 	beq	r2,r19,81ed8 <alt_find_file+0x74>
   81ed4:	1000051e 	bne	r2,zero,81eec <alt_find_file+0x88>
   81ed8:	8009883a 	mov	r4,r16
   81edc:	900b883a 	mov	r5,r18
   81ee0:	180d883a 	mov	r6,r3
   81ee4:	0081fc00 	call	81fc0 <memcmp>
   81ee8:	10000326 	beq	r2,zero,81ef8 <alt_find_file+0x94>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
   81eec:	8c400017 	ldw	r17,0(r17)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   81ef0:	8d7fec1e 	bne	r17,r21,81ea4 <alt_find_file+0x40>
   81ef4:	0023883a 	mov	r17,zero
  }
  
  /* No match found */
  
  return NULL;     
}
   81ef8:	8805883a 	mov	r2,r17
   81efc:	dfc00617 	ldw	ra,24(sp)
   81f00:	dd400517 	ldw	r21,20(sp)
   81f04:	dd000417 	ldw	r20,16(sp)
   81f08:	dcc00317 	ldw	r19,12(sp)
   81f0c:	dc800217 	ldw	r18,8(sp)
   81f10:	dc400117 	ldw	r17,4(sp)
   81f14:	dc000017 	ldw	r16,0(sp)
   81f18:	dec00704 	addi	sp,sp,28
   81f1c:	f800283a 	ret

00081f20 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   81f20:	defffb04 	addi	sp,sp,-20
   81f24:	dfc00415 	stw	ra,16(sp)
   81f28:	dcc00315 	stw	r19,12(sp)
   81f2c:	dc800215 	stw	r18,8(sp)
   81f30:	dc400115 	stw	r17,4(sp)
   81f34:	dc000015 	stw	r16,0(sp)
   81f38:	2025883a 	mov	r18,r4
   81f3c:	0021883a 	mov	r16,zero
   81f40:	00c00234 	movhi	r3,8
   81f44:	18ccb404 	addi	r3,r3,13008
   81f48:	04c00234 	movhi	r19,8
   81f4c:	9ccd1a04 	addi	r19,r19,13416
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  {
    if (!alt_fd_list[i].dev)
   81f50:	18800017 	ldw	r2,0(r3)
   81f54:	10000e1e 	bne	r2,zero,81f90 <alt_get_fd+0x70>
    {
      alt_fd_list[i].dev = dev;
   81f58:	8009883a 	mov	r4,r16
   81f5c:	01400304 	movi	r5,12
   81f60:	00820280 	call	82028 <__mulsi3>
   81f64:	00c00234 	movhi	r3,8
   81f68:	18ccb404 	addi	r3,r3,13008
   81f6c:	10c5883a 	add	r2,r2,r3
   81f70:	14800015 	stw	r18,0(r2)
      if (i > alt_max_fd)
   81f74:	98800017 	ldw	r2,0(r19)
   81f78:	14000216 	blt	r2,r16,81f84 <alt_get_fd+0x64>
   81f7c:	8005883a 	mov	r2,r16
   81f80:	00000806 	br	81fa4 <alt_get_fd+0x84>
      {
        alt_max_fd = i;
   81f84:	9c000015 	stw	r16,0(r19)
   81f88:	8005883a 	mov	r2,r16
   81f8c:	00000506 	br	81fa4 <alt_get_fd+0x84>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   81f90:	84000044 	addi	r16,r16,1
   81f94:	18c00304 	addi	r3,r3,12
   81f98:	00800804 	movi	r2,32
   81f9c:	80bfec1e 	bne	r16,r2,81f50 <alt_get_fd+0x30>
   81fa0:	00bffa04 	movi	r2,-24
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
}
   81fa4:	dfc00417 	ldw	ra,16(sp)
   81fa8:	dcc00317 	ldw	r19,12(sp)
   81fac:	dc800217 	ldw	r18,8(sp)
   81fb0:	dc400117 	ldw	r17,4(sp)
   81fb4:	dc000017 	ldw	r16,0(sp)
   81fb8:	dec00504 	addi	sp,sp,20
   81fbc:	f800283a 	ret

00081fc0 <memcmp>:
   81fc0:	31ffffc4 	addi	r7,r6,-1
   81fc4:	3000061e 	bne	r6,zero,81fe0 <memcmp+0x20>
   81fc8:	00000a06 	br	81ff4 <memcmp+0x34>
   81fcc:	39ffffc4 	addi	r7,r7,-1
   81fd0:	00bfffc4 	movi	r2,-1
   81fd4:	21000044 	addi	r4,r4,1
   81fd8:	29400044 	addi	r5,r5,1
   81fdc:	38800526 	beq	r7,r2,81ff4 <memcmp+0x34>
   81fe0:	20c00003 	ldbu	r3,0(r4)
   81fe4:	28800003 	ldbu	r2,0(r5)
   81fe8:	18bff826 	beq	r3,r2,81fcc <memcmp+0xc>
   81fec:	1885c83a 	sub	r2,r3,r2
   81ff0:	f800283a 	ret
   81ff4:	0005883a 	mov	r2,zero
   81ff8:	f800283a 	ret

00081ffc <memcpy>:
   81ffc:	2011883a 	mov	r8,r4
   82000:	30000726 	beq	r6,zero,82020 <memcpy+0x24>
   82004:	000f883a 	mov	r7,zero
   82008:	29c5883a 	add	r2,r5,r7
   8200c:	11000003 	ldbu	r4,0(r2)
   82010:	41c7883a 	add	r3,r8,r7
   82014:	39c00044 	addi	r7,r7,1
   82018:	19000005 	stb	r4,0(r3)
   8201c:	39bffa1e 	bne	r7,r6,82008 <memcpy+0xc>
   82020:	4005883a 	mov	r2,r8
   82024:	f800283a 	ret

00082028 <__mulsi3>:
   82028:	20000a26 	beq	r4,zero,82054 <__mulsi3+0x2c>
   8202c:	0007883a 	mov	r3,zero
   82030:	2080004c 	andi	r2,r4,1
   82034:	1005003a 	cmpeq	r2,r2,zero
   82038:	2008d07a 	srli	r4,r4,1
   8203c:	1000011e 	bne	r2,zero,82044 <__mulsi3+0x1c>
   82040:	1947883a 	add	r3,r3,r5
   82044:	294b883a 	add	r5,r5,r5
   82048:	203ff91e 	bne	r4,zero,82030 <__mulsi3+0x8>
   8204c:	1805883a 	mov	r2,r3
   82050:	f800283a 	ret
   82054:	0007883a 	mov	r3,zero
   82058:	1805883a 	mov	r2,r3
   8205c:	f800283a 	ret
